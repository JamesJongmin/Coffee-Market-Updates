<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coffee Market Updates Archive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-date-fns/2.0.0/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Arial', 'Helvetica', sans-serif;
            line-height: 1.7;
            color: #2c3e50;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            margin-bottom: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            font-weight: 300;
            margin-bottom: 15px;
        }
        
        .description {
            font-size: 1.1em;
            opacity: 0.8;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        /* Ï∞®Ìä∏ ÎåÄÏãúÎ≥¥Îìú Ïä§ÌÉÄÏùº */
        .dashboard-section {
            margin-bottom: 50px;
        }
        
        .section-title {
            font-size: 2em;
            font-weight: 700;
            color: #8B4513;
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 3px solid #8B4513;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
        }
        
        .chart-header {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .chart-source {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }
        
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
            font-size: 1.1em;
            color: #666;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #8B4513;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .stat-box {
            background: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-left: 5px solid #8B4513;
        }
        
        .stat-number {
            font-size: 2.2em;
            font-weight: 700;
            color: #8B4513;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.95em;
            color: #666;
            font-weight: 500;
        }
        
        .search-filter {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .filter-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .search-input {
            flex: 1;
            min-width: 250px;
            padding: 12px 15px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }
        
        .search-input:focus {
            border-color: #8B4513;
            outline: none;
        }
        
        .filter-select {
            padding: 12px 15px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-size: 1em;
            background: white;
            cursor: pointer;
        }
        
        .reports-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .report-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border-left: 5px solid #8B4513;
            cursor: pointer;
        }
        
        .report-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }
        
        .report-date {
            font-size: 0.9em;
            color: #8B4513;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .report-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .report-summary {
            font-size: 0.95em;
            color: #666;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .report-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .tag {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 500;
        }
        
        .read-more {
            display: inline-flex;
            align-items: center;
            color: #8B4513;
            font-weight: 600;
            text-decoration: none;
            font-size: 0.95em;
            transition: color 0.3s ease;
        }
        
        .read-more:hover {
            color: #A0522D;
        }
        
        .read-more::after {
            content: " ‚Üí";
            margin-left: 5px;
            transition: margin-left 0.3s ease;
        }
        
        .read-more:hover::after {
            margin-left: 10px;
        }
        
        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #666;
            font-size: 1.1em;
        }
        
        footer {
            text-align: center;
            padding: 30px 20px;
            color: #666;
            font-size: 0.9em;
            border-top: 1px solid #eee;
            margin-top: 40px;
            background: white;
            border-radius: 15px;
        }
        
        .footer-links {
            margin-top: 15px;
        }
        
        .footer-links a {
            color: #8B4513;
            text-decoration: none;
            margin: 0 15px;
            font-weight: 500;
        }
        
        .footer-links a:hover {
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2.2em;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .reports-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-input {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Coffee Market Updates</h1>
            <p class="subtitle">Coffee Futures Market Analysis & Dashboard</p>
            <p class="description">
                Ïª§Ìîº ÏÑ†Î¨º ÏãúÏû• Î∂ÑÏÑù Î≥¥Í≥†ÏÑú ÏïÑÏπ¥Ïù¥Î∏å Î∞è Ïã§ÏãúÍ∞Ñ ÏãúÏû• ÎåÄÏãúÎ≥¥ÎìúÏûÖÎãàÎã§. <br/>
                Ï£ºÍ∞Ñ ÏãúÏû• ÎèôÌñ•, Í∞ÄÍ≤© Î≥ÄÎèô Î∞è Í∏ÄÎ°úÎ≤å ÏàòÍ∏â ÌòÑÌô©ÏùÑ Ï†ïÍ∏∞Ï†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
            </p>
        </header>

        <!-- Ï∞®Ìä∏ ÎåÄÏãúÎ≥¥Îìú ÏÑπÏÖò -->
        <div class="dashboard-section">
            <h2 class="section-title">üìä Market Dashboard</h2>
            <div class="charts-grid">
                <!-- Coffee Futures Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Coffee Futures</div>
                        <div class="chart-source">Ï∂úÏ≤ò: ICE</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-coffee">
                            <div class="spinner"></div>
                            Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...
                        </div>
                        <canvas id="coffeeChart" style="display: none;"></canvas>
                    </div>
                </div>

                <!-- USD/BRL Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">ÎØ∏Íµ≠Îã¨Îü¨-Î∏åÎùºÏßàÌó§Ïïå ÌôòÏú®</div>
                        <div class="chart-source">Ï∂úÏ≤ò: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-usd">
                            <div class="spinner"></div>
                            Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...
                        </div>
                        <canvas id="usdChart" style="display: none;"></canvas>
                    </div>
                </div>

                <!-- CFTC Positions Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">CFTC Ìà¨Í∏∞ Ìè¨ÏßÄÏÖò (ÏàúÎß§Ïàò)</div>
                        <div class="chart-source">Ï∂úÏ≤ò: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-cftc">
                            <div class="spinner"></div>
                            Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...
                        </div>
                        <canvas id="cftcChart" style="display: none;"></canvas>
                    </div>
                </div>

                <!-- NVDI Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Î∏åÎùºÏßà ÎÇ®ÎèôÎ∂Ä NVDI (ÏãùÎ¨ºÌôúÎ†•ÎèÑ)</div>
                        <div class="chart-source">Ï∂úÏ≤ò: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-nvdi">
                            <div class="spinner"></div>
                            Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ï§ë...
                        </div>
                        <canvas id="nvdiChart" style="display: none;"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat-box">
                <div class="stat-number" id="totalReports">5</div>
                <div class="stat-label">Ï¥ù Î≥¥Í≥†ÏÑú Ïàò</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="latestDate">2025.06</div>
                <div class="stat-label">ÏµúÏã† ÏóÖÎç∞Ïù¥Ìä∏</div>
            </div>
            <div class="stat-box">
                <div class="stat-number">Ï£ºÍ∞Ñ</div>
                <div class="stat-label">ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞</div>
            </div>
            <div class="stat-box">
                <div class="stat-number">KR/EN</div>
                <div class="stat-label">Ïñ∏Ïñ¥ ÏßÄÏõê</div>
            </div>
        </div>

        <div class="search-filter">
            <div class="filter-row">
                <input type="text" class="search-input" id="searchInput" placeholder="Î≥¥Í≥†ÏÑú Ï†úÎ™©Ïù¥ÎÇò ÎÇ¥Ïö©ÏúºÎ°ú Í≤ÄÏÉâÌïòÏÑ∏Ïöî...">
                <select class="filter-select" id="yearFilter">
                    <option value="">Ï†ÑÏ≤¥ ÎÖÑÎèÑ</option>
                    <option value="2025">2025ÎÖÑ</option>
                </select>
                <select class="filter-select" id="monthFilter">
                    <option value="">Ï†ÑÏ≤¥ Ïõî</option>
                    <option value="05">5Ïõî</option>
                    <option value="06">6Ïõî</option>
                </select>
            </div>
        </div>

        <div class="reports-grid" id="reportsGrid">
            <!-- Î≥¥Í≥†ÏÑú Ïπ¥ÎìúÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§ -->
        </div>

        <div class="no-results" id="noResults" style="display: none;">
            <h3>Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§</h3>
            <p>Îã§Î•∏ Í≤ÄÏÉâÏñ¥ÎÇò ÌïÑÌÑ∞Î•º ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî.</p>
        </div>

        <footer>
            <p><strong>Published by Align Commodities & Yellowknife </strong></p>
            <p>Ï†ÑÎ¨∏Ï†ÅÏù∏ Ïª§Ìîº ÏãúÏû• Î∂ÑÏÑùÍ≥º Market IntelligenceÎ•º Ï†úÍ≥µÌï©ÎãàÎã§.</p>
            <div class="footer-links">
                <a href="mailto:james.baek@aligncommodities.com">Contact</a>
                <a href="https://github.com/jamesjongmin/Coffee-Market-Updates">GitHub</a>
                <a href="#latest">Latest Report</a>
            </div>
            <p style="margin-top: 15px; font-size: 0.8em; opacity: 0.7;">
                Î≥∏ Î¶¨Ìè¨Ìä∏Îäî Ï†ïÎ≥¥ Ï†úÍ≥µ Î™©Ï†ÅÏúºÎ°ú ÏûëÏÑ±ÎêòÏóàÏúºÎ©∞, Ìà¨Ïûê Í∂åÏú†Í∞Ä ÏïÑÎãôÎãàÎã§.
            </p>
        </footer>
    </div>
<script>
        let allReports = [];
        let charts = {};

        // ÏùºÎ∞ò Excel ÌååÏùº ÏùΩÍ∏∞ Ìï®Ïàò (2Ïª¨Îüº: Date, Value)
        async function readExcelFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${filename}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer);
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                
                const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                
                // Ï≤´ Î≤àÏß∏ ÌñâÏùÄ Ìó§Îçî, Îëê Î≤àÏß∏ ÌñâÏùÄ "Close" Îì±Ïùò Ï∂îÍ∞Ä Ìó§ÎçîÏù¥ÎØÄÎ°ú 3Î≤àÏß∏ ÌñâÎ∂ÄÌÑ∞ Îç∞Ïù¥ÌÑ∞
                const dataRows = data.slice(2);
                
                const processedData = dataRows.map(row => ({
                    date: row[0], // Ï≤´ Î≤àÏß∏ Ïª¨ÎüºÏùÄ Ìï≠ÏÉÅ Date
                    value: row[1] // Îëê Î≤àÏß∏ Ïª¨ÎüºÏùÄ Ìï¥Îãπ Í∞í
                })).filter(row => row.date && row.value !== undefined && row.value !== null);
                
                // ÎÇ†ÏßúÏàúÏúºÎ°ú Ï†ïÎ†¨ (Ïò§ÎûòÎêú Í≤É ‚Üí ÏµúÏã† ÏàúÏÑúÎ°ú)
                processedData.sort((a, b) => parseDate(a.date) - parseDate(b.date));
                
                return processedData;
                
            } catch (error) {
                console.error(`Error reading ${filename}:`, error);
                return null;
            }
        }

        // NVDI Excel ÌååÏùº ÏùΩÍ∏∞ Ìï®Ïàò (4Ïª¨Îüº: Date, Min-Max, Median, 2025)
        async function readNVDIExcelFile(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${filename}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer);
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                
                const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                
                // Ï≤´ Î≤àÏß∏ ÌñâÏùÄ Ìó§ÎçîÏù¥ÎØÄÎ°ú 2Î≤àÏß∏ ÌñâÎ∂ÄÌÑ∞ Îç∞Ïù¥ÌÑ∞
                const dataRows = data.slice(1);
                
                const processedData = dataRows.map(row => ({
                    date: row[0],      // Date
                    minMax: row[1],    // Min-Max (2001-2024)
                    median: row[2],    // Median (2001-2024)
                    year2025: row[3]   // 2025
                })).filter(row => row.date);
                
                return processedData;
                
            } catch (error) {
                console.error(`Error reading ${filename}:`, error);
                return null;
            }
        }

        // ÎÇ†Ïßú Î≥ÄÌôò Ìï®Ïàò
        function parseDate(dateValue) {
            if (typeof dateValue === 'number') {
                // Excel ÎÇ†Ïßú ÏãúÎ¶¨Ïñº Î≤àÌò∏Ïù∏ Í≤ΩÏö∞
                const date = new Date((dateValue - 25569) * 86400 * 1000);
                return date;
            } else if (typeof dateValue === 'string') {
                return new Date(dateValue);
            }
            return new Date(dateValue);
        }

        // Coffee Futures Ï∞®Ìä∏
        async function createCoffeeChart() {
            const loadingElement = document.getElementById('loading-coffee');
            const chartElement = document.getElementById('coffeeChart');
            
            try {
                const data = await Promise.race([
                    readExcelFile('coffeefutures.xlsx'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseFloat(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.coffee = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Coffee Futures Price',
                            data: chartData,
                            borderColor: '#8B4513',
                            backgroundColor: 'rgba(139, 69, 19, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#8B4513' : 'transparent'
                            ),
                            pointBorderColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#FFFFFF' : 'transparent'
                            ),
                            pointBorderWidth: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 2 : 0
                            ),
                            pointRadius: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 4 : 0
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index]) {
                                            const totalPoints = chartData.length;
                                            const interval = Math.max(1, Math.floor(totalPoints / 8));
                                            if (index % interval === 0 || index === totalPoints - 1) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    maxTicksLimit: 12,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Price (cents/lb)'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Coffee chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®: ' + error.message + '</div>';
            }
        }

        // USD/BRL ÌôòÏú® Ï∞®Ìä∏
        async function createUSDChart() {
            const loadingElement = document.getElementById('loading-usd');
            const chartElement = document.getElementById('usdChart');
            
            try {
                const data = await Promise.race([
                    readExcelFile('usdbrl.xlsx'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseFloat(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.usd = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'USD/BRL Rate',
                            data: chartData,
                            borderColor: '#2E8B57',
                            backgroundColor: 'rgba(46, 139, 87, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#2E8B57' : 'transparent'
                            ),
                            pointBorderColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#FFFFFF' : 'transparent'
                            ),
                            pointBorderWidth: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 2 : 0
                            ),
                            pointRadius: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 4 : 0
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index]) {
                                            const totalPoints = chartData.length;
                                            const interval = Math.max(1, Math.floor(totalPoints / 8));
                                            if (index % interval === 0 || index === totalPoints - 1) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    maxTicksLimit: 12,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'BRL per USD'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('USD chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®: ' + error.message + '</div>';
            }
        }

        // CFTC Ìè¨ÏßÄÏÖò Ï∞®Ìä∏
        async function createCFTCChart() {
            const loadingElement = document.getElementById('loading-cftc');
            const chartElement = document.getElementById('cftcChart');
            
            try {
                const data = await Promise.race([
                    readExcelFile('cftcpositions.xlsx'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseInt(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.cftc = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        datasets: [{
                            label: 'Net Long Positions',
                            data: chartData,
                            backgroundColor: chartData.map(point => point.y >= 0 ? '#27AE60' : '#E74C3C'),
                            borderColor: chartData.map(point => point.y >= 0 ? '#229954' : '#C0392B'),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index]) {
                                            // 3ÎÖÑ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú 2-3Í∞úÏõîÎßàÎã§ ÌëúÏãú
                                            const totalPoints = chartData.length;
                                            const interval = Math.max(1, Math.floor(totalPoints / 12));
                                            if (index % interval === 0 || index === totalPoints - 1) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    maxTicksLimit: 15,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Net Long Positions'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('CFTC chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®: ' + error.message + '</div>';
            }
        }

        // NVDI Ï∞®Ìä∏
        async function createNVDIChart() {
            const loadingElement = document.getElementById('loading-nvdi');
            const chartElement = document.getElementById('nvdiChart');
            
            try {
                const data = await Promise.race([
                    readNVDIExcelFile('MGvegetation.xlsx'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 5000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                console.log('NVDI data sample:', data.slice(0, 5));

                // ÎÇ†ÏßúÎ•º ÏõîÎ≥ÑÎ°ú ÌååÏã±ÌïòÍ≥† Ï†ïÎ†¨
                const monthOrder = ['Nov', 'Dec', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug'];
                const monthKR = ['11Ïõî', '12Ïõî', '1Ïõî', '2Ïõî', '3Ïõî', '4Ïõî', '5Ïõî', '6Ïõî', '7Ïõî', '8Ïõî'];
                
                // Îç∞Ïù¥ÌÑ∞Î•º ÏõîÎ≥ÑÎ°ú Í∑∏Î£πÌôî
                const monthlyData = {};
                monthOrder.forEach(month => {
                    monthlyData[month] = {
                        minMax: [],
                        median: [],
                        year2025: []
                    };
                });

                // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÌååÏã±
                data.forEach(row => {
                    if (row.date && typeof row.date === 'string') {
                        const dateParts = row.date.split('/');
                        if (dateParts.length === 2) {
                            const day = parseInt(dateParts[0]);
                            const month = parseInt(dateParts[1]);
                            
                            let monthKey = '';
                            if (month === 10) monthKey = 'Nov'; // 10Ïõî ‚Üí NovÎ°ú Îß§Ìïë
                            else if (month === 11) monthKey = 'Dec';
                            else if (month === 12) monthKey = 'Jan'; // Îã§ÏùåÎÖÑÎèÑ
                            else if (month <= 8) {
                                const monthMap = ['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug'];
                                monthKey = monthMap[month];
                            }
                            
                            if (monthKey && monthlyData[monthKey]) {
                                if (row.minMax && !isNaN(parseFloat(row.minMax))) {
                                    monthlyData[monthKey].minMax.push(parseFloat(row.minMax));
                                }
                                if (row.median && !isNaN(parseFloat(row.median))) {
                                    monthlyData[monthKey].median.push(parseFloat(row.median));
                                }
                                if (row.year2025 && !isNaN(parseFloat(row.year2025))) {
                                    monthlyData[monthKey].year2025.push(parseFloat(row.year2025));
                                }
                            }
                        }
                    }
                });

                // ÏõîÎ≥Ñ ÌèâÍ∑† Í≥ÑÏÇ∞
                const datasets = [];
                
                // Min-Max ÏòÅÏó≠ (ÏÉÅÌïúÏÑ†Í≥º ÌïòÌïúÏÑ†)
                const minValues = monthOrder.map((month, index) => {
                    const values = monthlyData[month].minMax;
                    return values.length > 0 ? Math.min(...values) : null;
                });
                
                const maxValues = monthOrder.map((month, index) => {
                    const values = monthlyData[month].minMax;
                    return values.length > 0 ? Math.max(...values) : null;
                });

                // Min-Max ÏòÅÏó≠ÏùÑ ÏùåÏòÅÏúºÎ°ú ÌëúÏãú
                datasets.push({
                    label: 'Min-Max Range (2001-2024)',
                    data: monthOrder.map((month, index) => ({
                        x: index,
                        y: maxValues[index]
                    })),
                    borderColor: 'rgba(149, 165, 166, 0.6)',
                    backgroundColor: 'rgba(149, 165, 166, 0.3)',
                    borderWidth: 1,
                    fill: '+1', // Îã§Ïùå Îç∞Ïù¥ÌÑ∞ÏÖãÍ≥º Ìï®Íªò ÏòÅÏó≠ Ï±ÑÏö∞Í∏∞
                    tension: 0.4,
                    pointRadius: 0
                });

                datasets.push({
                    label: '',
                    data: monthOrder.map((month, index) => ({
                        x: index,
                        y: minValues[index]
                    })),
                    borderColor: 'rgba(149, 165, 166, 0.6)',
                    backgroundColor: 'rgba(149, 165, 166, 0.3)',
                    borderWidth: 1,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0
                });

                // Median ÎùºÏù∏ (ÌååÎûÄÏÉâ)
                datasets.push({
                    label: 'Median (2001-2024)',
                    data: monthOrder.map((month, index) => {
                        const values = monthlyData[month].median;
                        return {
                            x: index,
                            y: values.length > 0 ? values.reduce((a, b) => a + b) / values.length : null
                        };
                    }),
                    borderColor: '#3498DB',
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: '#3498DB'
                });

                // 2025ÎÖÑ ÎùºÏù∏ (Îπ®Í∞ÑÏÉâ)
                datasets.push({
                    label: '2025',
                    data: monthOrder.map((month, index) => {
                        const values = monthlyData[month].year2025;
                        return {
                            x: index,
                            y: values.length > 0 ? values.reduce((a, b) => a + b) / values.length : null
                        };
                    }),
                    borderColor: '#E74C3C',
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 4,
                    pointBackgroundColor: '#E74C3C'
                });

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.nvdi = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    filter: function(item) {
                                        return item.text !== ''; // Îπà ÎùºÎ≤® Ïà®Í∏∞Í∏∞
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return monthKR[index];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: false
                                },
                                ticks: {
                                    callback: function(value) {
                                        return monthKR[value] || '';
                                    },
                                    maxTicksLimit: 10
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'NVDI Index'
                                },
                                min: 0.2,
                                max: 1.0
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('NVDI chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®: ' + error.message + '</div>';
            }
        }

        // ÌÇ§ÏõåÎìú Ï∂îÏ∂ú Ìï®Ïàò
        function extractKeywords(text) {
            // Ïª§Ìîº Í¥ÄÎ†® Ï†ÑÎ¨∏ Ïö©Ïñ¥ ÏÇ¨Ï†Ñ (Ïö∞ÏÑ†ÏàúÏúÑ ÎÜíÏùå)
            const coffeeTerms = {
                'ÏïÑÎùºÎπÑÏπ¥': 3, 'Î°úÎ∂ÄÏä§ÌÉÄ': 3, 'Ïª§Ìîº': 2,
                'Î∏åÎùºÏßà': 2, 'Î≤†Ìä∏ÎÇ®': 2, 'ÏΩúÎ°¨ÎπÑÏïÑ': 2, 'ÏóêÌã∞Ïò§ÌîºÏïÑ': 2,
                'ÏÉùÏÇ∞': 2, 'ÏàòÏ∂ú': 2, 'ÏàòÏûÖ': 2, 'Ïû¨Í≥†': 2,
                'ICE': 2, 'NYSE': 2, 'LIFFE': 2,
                'ÏÑ†Î¨º': 2, 'ÌòÑÎ¨º': 2, 'Í∞ÄÍ≤©': 2,
                'ÏàòÌôï': 2, 'ÏûëÌô©': 2, 'ÎÇ†Ïî®': 2, 'Í∞ÄÎ≠Ñ': 2, 'Í∞ïÏö∞': 2,
                'USDA': 2, 'ICO': 2, 'CONAB': 2,
                'Ìà¨Í∏∞': 1, 'Ìó§ÏßÄ': 1, 'ÌéÄÎìú': 1,
                'ÏÉÅÏäπ': 1, 'ÌïòÎùΩ': 1, 'Î≥ÄÎèôÏÑ±': 1,
                'ÏßÄÏßÄ': 1, 'Ï†ÄÌï≠': 1, 'ÎèåÌåå': 1,
                'ÌÜ§': 1, 'ÏÑºÌä∏': 1, 'Îã¨Îü¨': 1
            };

            // ÌÖçÏä§Ìä∏ Ï†ïÏ†ú
            const cleanText = text.toLowerCase()
                .replace(/[^\w\sÍ∞Ä-Ìû£]/g, ' ')
                .replace(/\s+/g, ' ');

            // Îã®Ïñ¥ ÎπàÎèÑ Í≥ÑÏÇ∞
            const wordCount = {};
            const words = cleanText.split(' ');
            
            words.forEach(word => {
                if (word.length >= 2) {
                    wordCount[word] = (wordCount[word] || 0) + 1;
                }
            });

            // Ï†êÏàò Í≥ÑÏÇ∞ (Ï†ÑÎ¨∏Ïö©Ïñ¥ Í∞ÄÏ§ëÏπò + ÎπàÎèÑ)
            const wordScores = {};
            Object.keys(wordCount).forEach(word => {
                const baseScore = wordCount[word];
                const termWeight = coffeeTerms[word] || 0;
                wordScores[word] = baseScore + (termWeight * 2);
            });

            // ÏÉÅÏúÑ ÌÇ§ÏõåÎìú ÏÑ†Î≥Ñ
            const sortedWords = Object.entries(wordScores)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 8)
                .map(([word]) => word)
                .filter(word => word.length >= 2);

            return sortedWords;
        }

        // HTML ÌååÏùºÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
        async function extractTextFromHTML(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) return '';
                
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // script, style ÌÉúÍ∑∏ Ï†úÍ±∞
                const scripts = doc.querySelectorAll('script, style');
                scripts.forEach(el => el.remove());
                
                // Î≥∏Î¨∏ ÌÖçÏä§Ìä∏Îßå Ï∂îÏ∂ú
                const bodyText = doc.body ? doc.body.textContent : '';
                return bodyText.replace(/\s+/g, ' ').trim();
                
            } catch (error) {
                console.error(`ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Ïã§Ìå® ${url}:`, error);
                return '';
            }
        }

        // Î≥¥Í≥†ÏÑúÏóê ÏûêÎèô ÌÉúÍ∑∏ Ï∂îÍ∞Ä
        async function addAutoTags(reports) {
            const updatedReports = [];
            
            for (const report of reports) {
                try {
                    const text = await extractTextFromHTML(report.link);
                    if (text) {
                        const autoTags = extractKeywords(text);
                        
                        updatedReports.push({
                            ...report,
                            tags: autoTags.slice(0, 6) // ÏµúÎåÄ 6Í∞ú ÌÉúÍ∑∏, ÏàúÏ†ÑÌûà ÏûêÎèô Ï∂îÏ∂úÎêú ÌÉúÍ∑∏Îßå ÏÇ¨Ïö©
                        });
                    } else {
                        // ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Ïã§Ìå® Ïãú Îπà ÌÉúÍ∑∏ Î∞∞Ïó¥
                        updatedReports.push({
                            ...report,
                            tags: []
                        });
                    }
                } catch (error) {
                    console.error(`ÌÉúÍ∑∏ Ï∂îÏ∂ú Ïã§Ìå® ${report.link}:`, error);
                    updatedReports.push({
                        ...report,
                        tags: []
                    });
                }
            }
            
            return updatedReports;
        }

        // Î≥¥Í≥†ÏÑú Î°úÎî© ÏóêÎü¨ Ï≤òÎ¶¨ Í∞úÏÑ†
        async function loadReportsFromJSON() {
            try {
                console.log('Î≥¥Í≥†ÏÑú Î°úÎî© ÏãúÏûë...');
                
                let reports = [];
                
                try {
                    const response = await fetch('reports.json');
                    if (response.ok) {
                        const data = await response.json();
                        reports = data.reports || [];
                        console.log('reports.jsonÏóêÏÑú Î°úÎìúÎêú Î≥¥Í≥†ÏÑú Ïàò:', reports.length);
                    } else {
                        console.log('reports.json ÏóÜÏùå, Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©');
                        throw new Error('reports.json not found');
                    }
                } catch (jsonError) {
                    console.log('JSON Î°úÎî© Ïã§Ìå®, Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©:', jsonError.message);
                    // reports.jsonÏù¥ ÏóÜÏúºÎ©¥ Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                    reports = [
                        {
                            date: '2025-06-14',
                            displayDate: '2025ÎÖÑ 6Ïõî 14Ïùº',
                            title: 'Îã®Í∏∞ Ïª§Ìîº ÏÑ†Î¨º Í∞ÄÍ≤© Ï†ÑÎßù Î∞è Î∞©Ìñ•ÏÑ± Ï†êÍ≤Ä',
                            subtitle: 'Short-term Coffee Futures Price Outlook & Direction Analysis',
                            summary: '',
                            tags: ['Ïª§Ìîº', 'ÏÑ†Î¨º', 'Ï†ÑÎßù'],
                            link: 'Reports/2025/06/2025-06-14.html',
                            year: '2025',
                            month: '06'
                        },
                        {
                            date: '2025-06-08',
                            displayDate: '2025ÎÖÑ 6Ïõî 8Ïùº',
                            title: 'Ïª§Ìîº ÏÑ†Î¨º ÏãúÏû• Ï£ºÍ∞Ñ ÎèôÌñ•',
                            subtitle: 'Coffee Futures Market Weekly Update',
                            summary: 'Ïª§Ìîº ÏÑ†Î¨ºÏù¥ ÏµúÍ∑º 1Ï£ºÏùºÍ∞Ñ 5.17% ÏÉÅÏäπÌïòÎ©∞ Î≥ÄÎèôÏÑ±Ïù¥ ÏßÄÏÜçÎêòÍ≥† ÏûàÏäµÎãàÎã§.',
                            tags: ['Ï£ºÍ∞ÑÎèôÌñ•', 'Î≥ÄÎèôÏÑ±'],
                            link: 'Reports/2025/06/2025-06-08.html',
                            year: '2025',
                            month: '06'
                        },
                        {
                            date: '2025-05-31',
                            displayDate: '2025ÎÖÑ 5Ïõî 31Ïùº',
                            title: 'Ïª§Ìîº ÏÑ†Î¨º ÏãúÏû• Ï£ºÍ∞Ñ ÎèôÌñ•',
                            subtitle: 'Coffee Futures Market Weekly Update',
                            summary: 'Ïª§Ìîº ÏÑ†Î¨º ÏãúÏû•Ïù¥ ÏßÄÎÇú Ìïú Îã¨Í∞ÑÏùò ÌïòÎùΩÏÑ∏Î•º Ïó∞Ïû•ÌïòÎ©∞ ÏÉàÎ°úÏö¥ Ï†ÄÏ†êÏùÑ Í∏∞Î°ùÌñàÏäµÎãàÎã§.',
                            tags: ['ÌïòÎùΩÏÑ∏', 'Ï†ÄÏ†ê'],
                            link: 'Reports/2025/05/2025-05-31.html',
                            year: '2025',
                            month: '05'
                        }
                    ];
                }
                
                console.log('ÏµúÏ¢Ö Î≥¥Í≥†ÏÑú Ïàò:', reports.length);
                
                // ÏûêÎèô ÌÉúÍ∑∏Îäî ÏÑ†ÌÉùÏ†ÅÏúºÎ°úÎßå Ï†ÅÏö© (ÏãúÍ∞ÑÏù¥ Ïò§Îûò Í±∏Î¶¥ Ïàò ÏûàÏùå)
                // const reportsWithAutoTags = await addAutoTags(reports);
                // return reportsWithAutoTags;
                
                return reports;
                
            } catch (error) {
                console.error('Î≥¥Í≥†ÏÑú Î°úÎî© Ï§ë Ïã¨Í∞ÅÌïú Ïò§Î•ò:', error);
                return [
                    {
                        date: '2025-06-14',
                        displayDate: '2025ÎÖÑ 6Ïõî 14Ïùº',
                        title: 'Îã®Í∏∞ Ïª§Ìîº ÏÑ†Î¨º Í∞ÄÍ≤© Ï†ÑÎßù Î∞è Î∞©Ìñ•ÏÑ± Ï†êÍ≤Ä',
                        subtitle: 'Short-term Coffee Futures Price Outlook & Direction Analysis',
                        summary: '',
                        tags: ['Ïª§Ìîº', 'ÏÑ†Î¨º'],
                        link: 'Reports/2025/06/2025-06-14.html',
                        year: '2025',
                        month: '06'
                    }
                ];
            }
        }

        function renderReports(filteredReports = allReports) {
            const grid = document.getElementById('reportsGrid');
            const noResults = document.getElementById('noResults');
            
            if (filteredReports.length === 0) {
                grid.style.display = 'none';
                noResults.style.display = 'block';
                return;
            }
            
            grid.style.display = 'grid';
            noResults.style.display = 'none';
            
            grid.innerHTML = filteredReports.map(report => `
                <div class="report-card" onclick="window.location.href='${report.link}'">
                    <div class="report-date">${report.displayDate}</div>
                    <h3 class="report-title">${report.title}</h3>
                    <p class="report-summary">${report.summary}</p>
                    <div class="report-tags">
                        ${report.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                    </div>
                    <a href="${report.link}" class="read-more">Î≥¥Í≥†ÏÑú ÏùΩÍ∏∞</a>
                </div>
            `).join('');
        }

        function filterReports() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const yearFilter = document.getElementById('yearFilter').value;
            const monthFilter = document.getElementById('monthFilter').value;
            
            const filtered = allReports.filter(report => {
                const matchesSearch = report.title.toLowerCase().includes(searchTerm) || 
                                    report.summary.toLowerCase().includes(searchTerm) ||
                                    report.tags.some(tag => tag.toLowerCase().includes(searchTerm));
                const matchesYear = !yearFilter || report.year === yearFilter;
                const matchesMonth = !monthFilter || report.month === monthFilter;
                
                return matchesSearch && matchesYear && matchesMonth;
            });
            
            renderReports(filtered);
        }

        function updateFilters() {
            const years = [...new Set(allReports.map(r => r.year))].sort().reverse();
            const months = [...new Set(allReports.map(r => r.month))].sort();
            
            const yearSelect = document.getElementById('yearFilter');
            const monthSelect = document.getElementById('monthFilter');
            
            if (yearSelect) {
                yearSelect.innerHTML = '<option value="">Ï†ÑÏ≤¥ ÎÖÑÎèÑ</option>';
                years.forEach(year => {
                    yearSelect.innerHTML += `<option value="${year}">${year}ÎÖÑ</option>`;
                });
            }
            
            if (monthSelect) {
                monthSelect.innerHTML = '<option value="">Ï†ÑÏ≤¥ Ïõî</option>';
                months.forEach(month => {
                    const monthName = parseInt(month) + 'Ïõî';
                    monthSelect.innerHTML += `<option value="${month}">${monthName}</option>`;
                });
            }
        }

        function updateStats() {
            const totalElement = document.getElementById('totalReports');
            const latestElement = document.getElementById('latestDate');
            
            if (totalElement) {
                totalElement.textContent = allReports.length;
            }
            
            if (latestElement && allReports.length > 0) {
                latestElement.textContent = allReports[0].displayDate.substring(0, 7);
            }
        }

        // Ï¥àÍ∏∞Ìôî Ìï®Ïàò
        async function init() {
            try {
                console.log('Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
                
                // Ï∞®Ìä∏Îì§ Î≥ëÎ†¨Î°ú Î°úÎìú
                Promise.all([
                    createCoffeeChart(),
                    createUSDChart(),
                    createCFTCChart(),
                    createNVDIChart()
                ]);

                // Î≥¥Í≥†ÏÑú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
                allReports = await loadReportsFromJSON();
                updateFilters();
                updateStats();
                renderReports();
                
                // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
                document.getElementById('searchInput').addEventListener('input', filterReports);
                document.getElementById('yearFilter').addEventListener('change', filterReports);
                document.getElementById('monthFilter').addEventListener('change', filterReports);
                
                console.log('Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
                
            } catch (error) {
                console.error('Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•ò:', error);
            }
        }

        // ÌéòÏù¥ÏßÄ Î°úÎìúÏãú Ï¥àÍ∏∞Ìôî Ïã§Ìñâ
        init();
</script>
</body>
</html>
