<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coffee Market Updates Archive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-date-fns/2.0.0/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.2.0/chartjs-plugin-datalabels.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Traffic Analytics & Management -->
    <script src="analytics-config.js"></script>
    
    <!-- Meta tags for SEO and Analytics -->
    <meta name="description" content="커피 선물 시장의 주간 동향과 분석을 제공하는 비즈니스 인텔리전스 플랫폼">
    <meta name="keywords" content="커피, 선물, 시장분석, 아라비카, 로부스타, 트레이딩, 비즈니스 인텔리전스">
    <meta name="author" content="Coffee Market Analysis Team">
    <meta property="og:title" content="Coffee Market Updates Archive">
    <meta property="og:description" content="커피 시장의 최신 동향과 분석 보고서">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://jamesjongmin.github.io/Coffee-Market-Updates/">
    <meta property="og:image" content="https://jamesjongmin.github.io/Coffee-Market-Updates/coffee-abstract-dark.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Coffee Market Updates Archive">
    <meta name="twitter:description" content="커피 시장의 최신 동향과 분석 보고서">
    <meta name="twitter:image" content="https://jamesjongmin.github.io/Coffee-Market-Updates/coffee-abstract-dark.jpg">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Arial', 'Helvetica', sans-serif;
            line-height: 1.7;
            color: #2c3e50;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('coffee-beans-pattern.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            opacity: 0.08;
            z-index: -1;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .logo-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 20px;
            padding-left: 10px;
        }
        
        .logo-header img {
            height: 80px;
            width: auto;
            object-fit: contain;
        }
        
        header {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            margin-bottom: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('coffee-abstract-dark.jpg');
            background-size: cover;
            background-position: center;
            opacity: 0.25;
            z-index: 0;
        }
        
        header > * {
            position: relative;
            z-index: 1;
        }
        
        h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .live-indicator {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.3em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
            animation: pulse-live 2s infinite;
        }
        
        .live-indicator::before {
            content: '●';
            color: #fff;
            font-size: 1.2em;
            margin-right: 4px;
            animation: blink 1.5s infinite;
        }
        
        @keyframes pulse-live {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        .date-badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.35em;
            font-weight: 500;
            border: 2px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            font-weight: 300;
            margin-bottom: 15px;
        }
        
        .description {
            font-size: 1.1em;
            opacity: 0.8;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .stats-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .stat-box {
            background: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-left: 5px solid #8B4513;
            position: relative;
            overflow: hidden;
        }
        
        .stat-box::after {
            content: '';
            position: absolute;
            bottom: -20px;
            right: -20px;
            width: 80px;
            height: 80px;
            background-image: url('coffee-beans-pattern.jpg');
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 0.15;
            transform: rotate(-15deg);
        }
        
        .stat-number {
            font-size: 2.2em;
            font-weight: 700;
            color: #8B4513;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.95em;
            color: #666;
            font-weight: 500;
        }
        
        .search-filter {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .filter-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .search-input {
            flex: 1;
            min-width: 250px;
            padding: 12px 15px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }
        
        .search-input:focus {
            border-color: #8B4513;
            outline: none;
        }
        
        .filter-select {
            padding: 12px 15px;
            border: 2px solid #eee;
            border-radius: 10px;
            font-size: 1em;
            background: white;
            cursor: pointer;
        }
        
        .reports-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .report-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border-left: 5px solid #8B4513;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .report-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background-image: url('coffee-beans-pattern.jpg');
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 0.08;
            transform: rotate(45deg);
            transition: opacity 0.3s ease;
        }
        
        .report-card:hover::before {
            opacity: 0.15;
        }
        
        .report-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }
        
        .report-date {
            font-size: 0.9em;
            color: #8B4513;
            font-weight: 600;
            margin-bottom: 10px;
        }
        
        .report-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            line-height: 1.4;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .new-badge {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            font-size: 0.7em;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.3);
            animation: pulse 2s infinite;
            flex-shrink: 0;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 2px 4px rgba(231, 76, 60, 0.3);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 8px rgba(231, 76, 60, 0.5);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 2px 4px rgba(231, 76, 60, 0.3);
            }
        }
        
        .report-summary {
            font-size: 0.95em;
            color: #666;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .report-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .tag {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 500;
        }
        
        .read-more {
            display: inline-flex;
            align-items: center;
            color: #8B4513;
            font-weight: 600;
            text-decoration: none;
            font-size: 0.95em;
            transition: color 0.3s ease;
        }
        
        .read-more:hover {
            color: #A0522D;
        }
        
        .read-more::after {
            content: " →";
            margin-left: 5px;
            transition: margin-left 0.3s ease;
        }
        
        .read-more:hover::after {
            margin-left: 10px;
        }
        
        .more-reports-container {
            text-align: center;
            margin: 30px 0;
        }
        
        .more-reports-btn {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 69, 19, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0 auto;
        }
        
        .more-reports-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 69, 19, 0.4);
            background: linear-gradient(135deg, #A0522D 0%, #8B4513 100%);
        }
        
        .more-reports-btn:active {
            transform: translateY(0);
        }
        
        .more-icon {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }
        
        .more-reports-btn.expanded .more-icon {
            transform: rotate(180deg);
        }
        
        .more-reports-btn.expanded .more-text::after {
            content: " Less";
        }
        
        .report-card.hidden {
            display: none;
        }
        
        .report-card.show-more {
            animation: fadeInUp 0.5s ease forwards;
        }
        
        .no-results {
            text-align: center;
            padding: 60px 20px;
            color: #666;
            font-size: 1.1em;
        }
        
        /* 차트 대시보드 스타일 */
        .dashboard-section {
            margin-bottom: 50px;
            position: relative;
        }
        
        .dashboard-section::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 600px;
            height: 600px;
            background-image: url('coffee-beans-pattern.jpg');
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 0.06;
            transform: translate(-50%, -50%) rotate(15deg);
            z-index: -1;
        }
        
        .section-title {
            font-size: 2em;
            font-weight: 700;
            color: #8B4513;
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 3px solid #8B4513;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
        }
        
        .chart-header {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .chart-source {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .chart-analysis {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid #8B4513;
            font-size: 0.9em;
            line-height: 1.5;
            color: #495057;
        }
        
        .chart-analysis .analysis-title {
            font-weight: 600;
            color: #8B4513;
            margin-bottom: 6px;
            font-size: 0.95em;
        }
        
        .chart-analysis .analysis-text {
            font-size: 0.85em;
            color: #6c757d;
        }
        
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 400px;
            font-size: 1.1em;
            color: #666;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #8B4513;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        footer {
            text-align: center;
            padding: 30px 20px;
            color: #666;
            font-size: 0.9em;
            border-top: 1px solid #eee;
            margin-top: 40px;
            background: white;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }
        
        .footer-logo {
            flex-shrink: 0;
        }
        
        .footer-logo img {
            height: 70px;
            width: auto;
            object-fit: contain;
        }
        
        .footer-content {
            flex: 0 1 auto;
            text-align: center;
            max-width: none;
        }
        
        .footer-links {
            margin-top: 15px;
        }
        
        .footer-links a {
            color: #8B4513;
            text-decoration: none;
            margin: 0 15px;
            font-weight: 500;
        }
        
        .footer-links a:hover {
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .logo-header {
                justify-content: center;
                margin-bottom: 15px;
            }
            
            .logo-header img {
                height: 65px;
            }
            
            h1 {
                font-size: 2.2em;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .reports-grid {
                grid-template-columns: 1fr;
            }
            
            .filter-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-input {
                min-width: auto;
            }
            
            footer {
                flex-direction: column;
                text-align: center;
                gap: 15px;
            }
            
            .footer-logo img {
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo-header">
            <img src="Transparent.png" alt="Align Commodities" />
        </div>
        
        <header>
            <div style="position: absolute; top: 20px; right: 20px; z-index: 10;">
                <a href="traffic-dashboard.html" style="background: rgba(255,255,255,0.2); color: white; text-decoration: none; padding: 8px 16px; border-radius: 20px; font-size: 0.9em; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.3); transition: all 0.3s ease;" 
                   onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                   onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                    📊 트래픽 대시보드
                </a>
            </div>
            <h1>
                Coffee Market Updates
                <span class="live-indicator">Live</span>
                <span class="date-badge" id="currentDate">2025년 6월 22일</span>
            </h1>
            <p class="subtitle">Coffee Futures Market Analysis & Dashboard</p>
            <p class="description">
                커피 선물 시장 분석 보고서 아카이브 및 실시간 시장 대시보드입니다. <br/>
                주간 시장 동향, 가격 변동 및 글로벌 수급 현황을 정기적으로 업데이트합니다.
            </p>
        </header>



        <div class="search-filter">
            <div class="filter-row">
                <input type="text" class="search-input" id="searchInput" placeholder="보고서 제목이나 내용으로 검색하세요...">
                <select class="filter-select" id="yearFilter">
                    <option value="">전체 년도</option>
                    <option value="2025">2025년</option>
                </select>
                <select class="filter-select" id="monthFilter">
                    <option value="">전체 월</option>
                    <option value="05">5월</option>
                    <option value="06">6월</option>
                </select>
            </div>
        </div>

        <div class="reports-grid" id="reportsGrid">
            <!-- 보고서 카드들이 여기에 동적으로 추가됩니다 -->
        </div>

        <div class="more-reports-container" id="moreReportsContainer" style="display: none;">
            <button class="more-reports-btn" id="moreReportsBtn">
                <span class="more-text">More Reports</span>
                <span class="more-icon">▼</span>
            </button>
        </div>

        <div class="no-results" id="noResults" style="display: none;">
            <h3>검색 결과가 없습니다</h3>
            <p>다른 검색어나 필터를 시도해보세요.</p>
        </div>

        <!-- 차트 대시보드 섹션 -->
        <div class="dashboard-section">
            <h2 class="section-title">📊 Market Dashboard</h2>
            <div class="charts-grid">
                <!-- Coffee Futures Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Coffee Futures</div>
                        <div class="chart-source">출처: ICE</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-coffee">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="coffeeChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">📊 차트 분석</div>
                        <div class="analysis-text">
                            <strong>커피 선물 가격</strong>은 글로벌 커피 시장의 미래 가격 기대치를 반영합니다. 
                            브라질/베트남 등 주요 생산국의 작황, 기후 변화, 글로벌 수요 변화가 주요 변동 요인입니다. 
                            현재 추세는 시장의 공급/수요 균형과 투기적 포지션 변화를 나타냅니다.
                        </div>
                    </div>
                </div>

                <!-- USD/BRL Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">미국달러-브라질헤알 환율</div>
                        <div class="chart-source">출처: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-usd">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="usdChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">💱 차트 분석</div>
                        <div class="analysis-text">
                            <strong>USD/BRL 환율</strong>은 커피 시장에 중요한 영향을 미칩니다. 
                            헤알화 약세(USD/BRL 상승) 시 브라질 농민들의 달러 수취액이 증가해 수출 경쟁력이 강화되고, 
                            반대로 헤알화 강세 시에는 브라질 커피의 국제 경쟁력이 약화됩니다. 
                            브라질이 세계 최대 커피 생산국이므로 환율 변동은 글로벌 커피 가격에 직접적 영향을 줍니다.
                        </div>
                    </div>
                </div>

                <!-- CFTC Positions Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">CFTC 투기 포지션 (순매수)</div>
                        <div class="chart-source">출처: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-cftc">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="cftcChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">📈 차트 분석</div>
                        <div class="analysis-text">
                            <strong>CFTC 머니매니저 순매수 포지션</strong>은 대형 펀드들의 커피 시장 심리를 보여줍니다. 
                            양수는 강세 베팅(매수 우세), 음수는 약세 베팅(매도 우세)을 의미합니다. 
                            극단적 포지션은 종종 시장 전환점의 신호가 되며, 
                            현재 포지션 수준은 투기 자금의 방향성과 시장 과열/과매도 상태를 판단하는 중요한 지표입니다.
                        </div>
                    </div>
                </div>

                <!-- NVDI Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">브라질 남동부 NVDI (식물활력도)</div>
                        <div class="chart-source">출처: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-nvdi">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="nvdiChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">🌱 차트 분석</div>
                        <div class="analysis-text">
                            <strong>NVDI (정규식생지수)</strong>는 위성 데이터로 측정한 식물의 건강도와 활력도를 나타냅니다. 
                            브라질 남동부는 세계 최대 아라비카 커피 생산지역으로, NVDI 수치가 높을수록 커피나무가 건강하고 
                            수확량 증가가 예상됩니다. 역사적 범위 대비 현재 수치를 통해 
                            올해 작황 상태와 향후 공급량 전망을 예측할 수 있는 핵심 지표입니다.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div class="footer-logo">
                <img src="Transparent.png" alt="Align Commodities" />
            </div>
            <div class="footer-content">
                <p><strong>Published by Align Commodities & Yellowknife </strong></p>
                <p>전문적인 커피 시장 분석과 Market Intelligence를 제공합니다.</p>
                <div class="footer-links">
                    <a href="mailto:james.baek@aligncommodities.com">Contact</a>
                    <a href="https://github.com/jamesjongmin/Coffee-Market-Updates">GitHub</a>
                    <a href="#" id="latestReportLink">Latest Report</a>
                </div>
                <p style="margin-top: 15px; font-size: 0.8em; opacity: 0.7;">
                    본 리포트는 정보 제공 목적으로 작성되었으며, 투자 권유가 아닙니다.
                </p>
            </div>
        </footer>
    </div>
<script>
        let allReports = [];
        let charts = {};

        // 구글 시트 URL 설정
        const GOOGLE_SHEETS_URLS = {
            coffeefutures: 'https://docs.google.com/spreadsheets/d/1lnRrdQynfk-XrgYsKmf1_XFCBDa9jLr2XVRib-2lpTk/export?format=csv&gid=442491515',
            usdbrl: 'https://docs.google.com/spreadsheets/d/1FvqTjVTw_iCtZ9pQOHc1UBN7ghYvrdp_MOLTxsSLTyM/export?format=csv&gid=88171284',
            cftcpositions: 'https://docs.google.com/spreadsheets/d/1IgfIFB60VC2f3IGnU5m9xmqkmfOCnnAOYItj9SWKMxc/export?format=csv&gid=0',
            nvdi: 'https://docs.google.com/spreadsheets/d/1oxXXeBQDZmiq9te6fNkKTs9D1X8ruwUI0_yy8UOj7gI/export?format=csv&gid=0'
        };

        // CSV 파싱 함수
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const cells = line.split(',');
                    result.push(cells);
                }
            }
            
            return result;
        }

        // 구글 시트에서 데이터 읽기 함수 (2컬럼: Date, Value)
        async function readGoogleSheetData(sheetKey) {
            try {
                const url = GOOGLE_SHEETS_URLS[sheetKey];
                if (!url) {
                    throw new Error(`Unknown sheet key: ${sheetKey}`);
                }

                console.log(`Fetching data from Google Sheets: ${sheetKey}`);
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const csvText = await response.text();
                const data = parseCSV(csvText);
                
                // 첫 번째 행은 헤더이므로 제외하고 데이터 처리
                const dataRows = data.slice(1);
                
                const processedData = dataRows.map(row => ({
                    date: row[0], // 첫 번째 컬럼은 항상 Date
                    value: row[1] // 두 번째 컬럼은 해당 값
                })).filter(row => row.date && row.value !== undefined && row.value !== null && row.value !== '');
                
                // 날짜순으로 정렬 (오래된 것 → 최신 순서로)
                processedData.sort((a, b) => parseDate(a.date) - parseDate(b.date));
                
                console.log(`Successfully loaded ${processedData.length} data points from ${sheetKey}`);
                return processedData;
                
            } catch (error) {
                console.error(`Error reading Google Sheet ${sheetKey}:`, error);
                return null;
            }
        }

        // 개선된 리포트 로딩 시스템 - 메타데이터 우선, 다중 폴백
        async function loadReportsFromFiles() {
            // 실제 리포트 파일 목록 (올바른 경로, 최신순 정렬)
            const reportFiles = [
                'Reports/2025/07/2025-07-26.html',       
                'Reports/2025/07/2025-07-25.html',       
                'Reports/2025/07/2025-07-19.html',   
                'Reports/2025/07/2025-07-16.html',
                'Reports/2025/07/2025-07-12.html',
                'Reports/2025/07/2025-07-09.html',
                'Reports/2025/07/2025-07-04.html',
                'Reports/2025/06/2025-06-30.html',
                'Reports/2025/06/2025-06-28.html',
                'Reports/2025/06/2025-06-24.html', 
                'Reports/2025/06/2025-06-21.html',
                'Reports/2025/06/2025-06-14.html',
                'Reports/2025/06/2025-06-13.html',
                'Reports/2025/06/2025-06-09.html',
                'Reports/2025/06/2025-06-08.html',
                'Reports/2025/05/2025-05-31.html'  // 5월 폴더의 리포트
                // 새 리포트 추가 시 여기 맨 위에 올바른 경로로 추가하면 됩니다
                // 예: 'Reports/2025/07/2025-07-01.html'
            ];
            
            const reports = [];
            
            for (const filePath of reportFiles) {
                try {
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        console.log(`파일 없음: ${filePath}`);
                        continue;
                    }
                    
                    const htmlContent = await response.text();
                    const metadata = extractReportMetadata(htmlContent, filePath);
                    
                    if (metadata) {
                        reports.push({
                            ...metadata,
                            link: filePath,
                            year: metadata.date.split('-')[0],
                            month: metadata.date.split('-')[1],
                            displayDate: formatKoreanDate(metadata.date)
                        });
                        console.log(`성공적으로 로드: ${filePath}`);
                    }
                } catch (error) {
                    console.error(`로딩 실패 ${filePath}:`, error);
                }
            }
            
            return reports.sort((a, b) => new Date(b.date) - new Date(a.date));
        }

        // 메타데이터 추출 함수 (개선된 폴백 시스템)
        function extractReportMetadata(htmlContent, filePath) {
            // 1단계: HTML 메타데이터 블록 검색
            const metaMatch = htmlContent.match(/<!--REPORT_META\s*([\s\S]*?)\s*REPORT_META-->/);
            
            if (metaMatch) {
                try {
                    const metadata = JSON.parse(metaMatch[1].trim());
                    console.log(`메타데이터 블록에서 로드: ${filePath}`);
                    return metadata;
                } catch (error) {
                    console.error(`메타데이터 파싱 실패 ${filePath}:`, error);
                }
            }
            
            // 2단계: 기존 방식 폴백 (개선된 버전)
            return extractLegacyMetadata(htmlContent, filePath);
        }

        // 기존 방식 폴백 (안전한 추출)
        function extractLegacyMetadata(htmlContent, filePath) {
            // 특수 파일들을 위한 하드코딩된 메타데이터
            const specialFiles = {
                'Reports/2025/06/2025-06-14.html': {
                    title: '단기 커피 선물 가격 전망 및 방향성 점검',
                    summary: 'KCN25는 349.90센트로 +0.60% 상승하며 1차 지지선을 상회 회복했습니다. 단기적으로는 브라질 수확 진행과 투기적 숏 포지션이 하방 압력으로 작용하나, 구조적으로는 글로벌 아라비카 적자와 25년 만에 최저 재고가 강세 요인으로 작용합니다.',
                    tags: ['단기전망', '기술적분석', '브라질수확', '아라비카적자', '투기포지션']
                },
                'Reports/2025/06/2025-06-24.html': {
                    title: '커피 가격, 폭풍 전야 - 아라비카 시장 인포그래픽',
                    summary: '아라비카 커피 시장은 강력한 강세 요인과 잠재적 약세 리스크가 충돌하며 높은 변동성을 예고하고 있습니다. 단기 가격 전망은 310-390센트 범위이며, 브라질 서리 위험이 핵심 변수로 작용할 전망입니다.',
                    tags: ['인포그래픽', '가격전망', '브라질서리', '공급부족', '변동성']
                }
            };

            // 특수 파일인지 확인
            if (specialFiles[filePath]) {
                console.log(`특수 파일 처리: ${filePath}`);
                const fileData = specialFiles[filePath];
                const dateMatch = filePath.match(/(\d{4}-\d{2}-\d{2})/);
                return {
                    title: fileData.title,
                    subtitle: '',
                    date: dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0],
                    summary: fileData.summary,
                    tags: fileData.tags
                };
            }

            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            
            // 파일명에서 날짜 추출
            const dateMatch = filePath.match(/(\d{4}-\d{2}-\d{2})/);
            const defaultDate = dateMatch ? dateMatch[1] : new Date().toISOString().split('T')[0];
            
            // 제목 추출 (개선된 셀렉터)
            const titleSelectors = [
                'h1',                    // 메인 제목
                '.main-story h2',        // 주요 스토리 제목
                'header h1',             // 헤더의 제목
                'title'                  // HTML title 태그
            ];
            
            let title = '';
            for (const selector of titleSelectors) {
                const element = doc.querySelector(selector);
                if (element && element.textContent.trim()) {
                    title = cleanText(element.textContent.trim());
                    // HTML 태그나 스타일 코드가 포함된 경우 제외
                    if (!title.includes('<') && !title.includes('{') && title.length > 5) {
                        break;
                    }
                }
            }
            
            // 요약 추출 (안전한 방식)
            let summary = '';
            const summarySelectors = [
                '.highlight p',           // 하이라이트 박스
                '.main-story p:first-of-type',  // 주요 스토리 첫 문단
                '.summary',               // 요약 전용 클래스
                'meta[name="description"]' // 메타 설명
            ];
            
            for (const selector of summarySelectors) {
                const element = doc.querySelector(selector);
                if (element) {
                    const text = selector.includes('meta') ? 
                        element.getAttribute('content') : 
                        element.textContent;
                    
                    if (text && text.trim()) {
                        const cleanedText = cleanText(text.trim());
                        // HTML 코드나 스타일이 포함되지 않고 적절한 길이인지 확인
                        if (!cleanedText.includes('<') && 
                            !cleanedText.includes('{') && 
                            !cleanedText.includes('function') &&
                            cleanedText.length > 20 && 
                            cleanedText.length < 300) {
                            summary = cleanedText.substring(0, 200);
                            break;
                        }
                    }
                }
            }
            
            // 태그 추출 (기존 .tag 클래스에서)
            const tags = Array.from(doc.querySelectorAll('.tag'))
                .map(tag => cleanText(tag.textContent.trim()))
                .filter(tag => tag && tag.length > 0 && tag.length < 20)
                .slice(0, 6);
            
            console.log(`폴백 방식으로 추출된 데이터: ${filePath}`);
            
            return {
                title: title || getDefaultTitle(filePath),
                subtitle: '',
                date: defaultDate,
                summary: summary || '',
                tags: tags
            };
        }

        // 텍스트 정제 함수
        function cleanText(text) {
            return text
                .replace(/\s+/g, ' ')        // 여러 공백을 하나로
                .replace(/[^\w\s가-힣.,!?-]/g, '') // 특수문자 제거 (한글, 영문, 숫자, 기본 문장부호만 유지)
                .trim();
        }

        // 기본 제목 생성
        function getDefaultTitle(filePath) {
            const dateMatch = filePath.match(/(\d{4}-\d{2}-\d{2})/);
            if (dateMatch) {
                return `커피 시장 동향 - ${dateMatch[1]}`;
            }
            return '커피 시장 동향';
        }

        // 날짜 포맷팅 함수
        function formatKoreanDate(dateString) {
            try {
                const date = new Date(dateString);
                return date.toLocaleDateString('ko-KR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            } catch (error) {
                return dateString;
            }
        }

        // JSON 폴백 함수 (기존 reports.json 지원)
        async function loadReportsFromJSON() {
            try {
                const response = await fetch('reports.json');
                if (response.ok) {
                    const data = await response.json();
                    console.log('reports.json에서 로드된 보고서 수:', data.reports?.length || 0);
                    return data.reports || [];
                }
            } catch (error) {
                console.log('reports.json 로딩 실패:', error.message);
            }
            return [];
        }

        // 기본 데이터 (올바른 경로 기반)
        function getDefaultReports() {
            return [
                {
                    date: '2025-06-28',
                    displayDate: '2025년 6월 28일',
                    title: '커피 시장 동향 - 2025-06-28',
                    subtitle: 'Coffee Market Update',
                    summary: '커피 시장 주간 동향 및 분석 보고서입니다.',
                    tags: ['커피', '시장동향'],
                    link: 'Reports/2025/06/2025-06-28.html',
                    year: '2025',
                    month: '06'
                },
                {
                    date: '2025-06-24',
                    displayDate: '2025년 6월 24일',
                    title: '커피 시장 동향 - 2025-06-24',
                    subtitle: 'Coffee Market Update',
                    summary: '커피 시장 주간 동향 및 분석 보고서입니다.',
                    tags: ['커피', '시장동향'],
                    link: 'Reports/2025/06/2025-06-24.html',
                    year: '2025',
                    month: '06'
                },
                {
                    date: '2025-06-21',
                    displayDate: '2025년 6월 21일',
                    title: '커피 시장 동향 - 2025-06-21',
                    subtitle: 'Coffee Market Update',
                    summary: '커피 시장 주간 동향 및 분석 보고서입니다.',
                    tags: ['커피', '시장동향'],
                    link: 'Reports/2025/06/2025-06-21.html',
                    year: '2025',
                    month: '06'
                },
                {
                    date: '2025-05-31',
                    displayDate: '2025년 5월 31일',
                    title: '커피 시장 동향 - 2025-05-31',
                    subtitle: 'Coffee Market Update',
                    summary: '커피 시장 주간 동향 및 분석 보고서입니다.',
                    tags: ['커피', '시장동향'],
                    link: 'Reports/2025/05/2025-05-31.html',
                    year: '2025',
                    month: '05'
                }
            ];
        }

        // 메인 리포트 초기화 함수 (JSON 제거 버전)
        async function initializeReports() {
            try {
                console.log('리포트 초기화 시작...');
                
                // HTML 파일에서 직접 로드 (JSON 폴백 제거)
                let reports = await loadReportsFromFiles();
                console.log('파일에서 로드된 리포트:', reports.length);
                
                // 로드 실패 시 기본 데이터 사용
                if (reports.length === 0) {
                    console.log('파일 로드 실패, 기본 데이터 사용');
                    reports = getDefaultReports();
                }
                
                console.log('최종 리포트 수:', reports.length);
                return reports;
                
            } catch (error) {
                console.error('리포트 초기화 중 오류:', error);
                return getDefaultReports();
            }
        }

        // 날짜 변환 함수
        function parseDate(dateValue) {
            if (typeof dateValue === 'number') {
                // Excel 날짜 시리얼 번호인 경우
                const date = new Date((dateValue - 25569) * 86400 * 1000);
                return date;
            } else if (typeof dateValue === 'string') {
                return new Date(dateValue);
            }
            return new Date(dateValue);
        }

        // Coffee Futures 차트
        async function createCoffeeChart() {
            const loadingElement = document.getElementById('loading-coffee');
            const chartElement = document.getElementById('coffeeChart');
            
            try {
                const data = await Promise.race([
                    readGoogleSheetData('coffeefutures'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseFloat(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.coffee = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Coffee Futures Price',
                            data: chartData,
                            borderColor: '#8B4513',
                            backgroundColor: 'rgba(139, 69, 19, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#8B4513' : 'transparent'
                            ),
                            pointBorderColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#FFFFFF' : 'transparent'
                            ),
                            pointBorderWidth: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 2 : 0
                            ),
                            pointRadius: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 4 : 0
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index] && index >= 0 && index < chartData.length) {
                                            const totalPoints = chartData.length;
                                            const step = Math.max(1, Math.floor(totalPoints / 8));
                                            
                                            if (index === 0 || index === totalPoints - 1 || index % step === 0) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    stepSize: Math.max(1, Math.floor(chartData.length / 8)),
                                    maxTicksLimit: 10,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Price (cents/lb)'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Coffee chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">데이터 로딩 실패: ' + error.message + '</div>';
            }
        }

        // USD/BRL 환율 차트
        async function createUSDChart() {
            const loadingElement = document.getElementById('loading-usd');
            const chartElement = document.getElementById('usdChart');
            
            try {
                const data = await Promise.race([
                    readGoogleSheetData('usdbrl'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseFloat(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.usd = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'USD/BRL Rate',
                            data: chartData,
                            borderColor: '#2E8B57',
                            backgroundColor: 'rgba(46, 139, 87, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#2E8B57' : 'transparent'
                            ),
                            pointBorderColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#FFFFFF' : 'transparent'
                            ),
                            pointBorderWidth: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 2 : 0
                            ),
                            pointRadius: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 4 : 0
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index] && index >= 0 && index < chartData.length) {
                                            const totalPoints = chartData.length;
                                            const step = Math.max(1, Math.floor(totalPoints / 8));
                                            
                                            if (index === 0 || index === totalPoints - 1 || index % step === 0) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    stepSize: Math.max(1, Math.floor(chartData.length / 8)),
                                    maxTicksLimit: 10,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'BRL per USD'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('USD chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">데이터 로딩 실패: ' + error.message + '</div>';
            }
        }

        // CFTC 포지션 차트 (바 차트 레이블 문제 해결)
        async function createCFTCChart() {
            const loadingElement = document.getElementById('loading-cftc');
            const chartElement = document.getElementById('cftcChart');
            
            try {
                const data = await Promise.race([
                    readGoogleSheetData('cftcpositions'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                console.log('CFTC Raw data sample:', data.slice(0, 3));

                const chartData = data.map((row) => ({
                    y: parseInt(row.value),
                    date: parseDate(row.date),
                    dateString: row.date
                })).filter(point => !isNaN(point.y) && point.date);

                // 날짜 기준으로 정렬
                chartData.sort((a, b) => a.date.getTime() - b.date.getTime());

                console.log('CFTC Processed data sample:', {
                    total: chartData.length,
                    first: chartData[0],
                    last: chartData[chartData.length - 1]
                });

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                
                // 모바일 여부 확인
                const isMobile = window.innerWidth <= 768;
                
                // 3개월 간격으로 레이블 인덱스 선택 (바 차트용)
                const totalData = chartData.length;
                const step = Math.max(Math.floor(totalData / 6), 1);
                
                // **핵심 수정**: 바 차트용 레이블을 모든 데이터 포인트에 대해 생성
                // 빈 문자열이 아닌 실제 날짜 문자열로 생성
                const labels = chartData.map((item, index) => {
                    // 선택된 인덱스에만 실제 날짜 표시, 나머지는 공백으로 처리하되 구조는 유지
                    if (index === 0 || index === totalData - 1 || index % step === 0) {
                        if (isMobile) {
                            return item.date.toLocaleDateString('ko-KR', { 
                                year: '2-digit',
                                month: 'short'
                            });
                        } else {
                            return item.date.toLocaleDateString('ko-KR', { 
                                year: 'numeric', 
                                month: 'long'
                            });
                        }
                    }
                    // 빈 레이블이지만 Chart.js가 인식할 수 있도록 공백 반환
                    return ' ';
                });
                
                console.log('Generated labels count:', labels.length);
                console.log('Non-empty labels:', labels.filter(l => l.trim() !== ''));
                
                charts.cftc = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Net Long Positions',
                            data: chartData.map(d => d.y),
                            backgroundColor: chartData.map(point => point.y >= 0 ? '#27AE60' : '#E74C3C'),
                            borderColor: chartData.map(point => point.y >= 0 ? '#229954' : '#C0392B'),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR', {
                                            year: 'numeric',
                                            month: 'long',
                                            day: 'numeric'
                                        });
                                    },
                                    label: function(context) {
                                        return 'Net Long: ' + context.parsed.y.toLocaleString();
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date (3개월 단위)'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 0,
                                    font: {
                                        size: isMobile ? 11 : 13,
                                        weight: 'bold'
                                    },
                                    color: '#333',
                                    // **핵심 수정**: autoSkip을 false로 설정하여 모든 레이블 표시 시도
                                    autoSkip: false,
                                    // maxTicksLimit 제거하여 제한 없애기
                                    // maxTicksLimit: 제거
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Net Long Positions'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    }
                                }
                            }
                        }
                    }
                });
                
                console.log('CFTC Chart created successfully');
                console.log('Chart labels:', charts.cftc.data.labels.filter(l => l.trim() !== ''));
                
            } catch (error) {
                console.error('CFTC chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">데이터 로딩 실패: ' + error.message + '</div>';
            }
        }

        // NVDI 차트 (구글 시트에서 읽기)
        async function createNVDIChart() {
            const loadingElement = document.getElementById('loading-nvdi');
            const chartElement = document.getElementById('nvdiChart');
            
            try {
                const nvdiData = await Promise.race([
                    readNVDIGoogleSheet(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!nvdiData || nvdiData.length === 0) {
                    throw new Error('NVDI 데이터를 읽을 수 없습니다');
                }

                const monthKR = ['1월', '2월', '3월', '4월', '5월', '6월', 
                               '7월', '8월', '9월', '10월', '11월', '12월'];

                const datasets = [];

                // Min-Max 범위 상한선
                const maxData = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.maxValue
                })).filter(point => point.y !== null);

                datasets.push({
                    label: 'Historical Range (2010-2023)',
                    data: maxData,
                    borderColor: 'rgba(149, 165, 166, 0.8)',
                    backgroundColor: 'rgba(149, 165, 166, 0.3)',
                    borderWidth: 1,
                    fill: '+1',
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 0
                });

                // Min-Max 범위 하한선
                const minData = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.minValue
                })).filter(point => point.y !== null);

                datasets.push({
                    label: '',
                    data: minData,
                    borderColor: 'rgba(149, 165, 166, 0.8)',
                    backgroundColor: 'rgba(149, 165, 166, 0.3)',
                    borderWidth: 1,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 0
                });

                // 2024년 라인
                const data2024 = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.year2024
                })).filter(point => point.y !== null && !isNaN(point.y));

                if (data2024.length > 0) {
                    datasets.push({
                        label: '2024',
                        data: data2024,
                        borderColor: '#E74C3C',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#E74C3C',
                        pointBorderColor: '#FFFFFF',
                        pointBorderWidth: 2
                    });
                }

                // 2025년 라인
                const data2025 = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.year2025
                })).filter(point => point.y !== null && !isNaN(point.y));

                if (data2025.length > 0) {
                    datasets.push({
                        label: '2025',
                        data: data2025,
                        borderColor: '#3498DB',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#3498DB',
                        pointBorderColor: '#FFFFFF',
                        pointBorderWidth: 2
                    });
                }

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.nvdi = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    filter: function(item) {
                                        return item.text !== '';
                                    },
                                    usePointStyle: false,
                                    padding: 20,
                                    font: {
                                        size: 12
                                    },
                                    generateLabels: function(chart) {
                                        const datasets = chart.data.datasets;
                                        return datasets.map((dataset, i) => {
                                            if (dataset.label && dataset.label !== '') {
                                                return {
                                                    text: dataset.label,
                                                    fillStyle: dataset.borderColor,
                                                    strokeStyle: dataset.borderColor,
                                                    lineWidth: 3,
                                                    hidden: !chart.isDatasetVisible(i),
                                                    datasetIndex: i
                                                };
                                            }
                                        }).filter(item => item);
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return monthKR[index] || `월 ${index + 1}`;
                                    },
                                    label: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const dataPoint = nvdiData[index];
                                            if (dataPoint) {
                                                return `Range: ${dataPoint.minValue?.toFixed(3)} - ${dataPoint.maxValue?.toFixed(3)}`;
                                            }
                                            return 'Range data';
                                        } else if (context.datasetIndex === 1) {
                                            return '';
                                        }
                                        return context.dataset.label + ': ' + (context.parsed.y ? context.parsed.y.toFixed(3) : 'N/A');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: '월',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        return monthKR[index] || '';
                                    },
                                    maxTicksLimit: 12,
                                    stepSize: 1
                                },
                                min: 0,
                                max: 11,
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'NVDI Index',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
                
                console.log('NVDI 차트 생성 완료');
                
            } catch (error) {
                console.error('NVDI chart error:', error);
                loadingElement.innerHTML = `
                    <div style="color: #e74c3c; text-align: center;">
                        <strong>NVDI 데이터 로딩 실패</strong><br>
                        <small>${error.message}</small><br>
                        <small style="margin-top: 10px; display: block;">
                            구글 시트에서 데이터를 읽을 수 없습니다.
                        </small>
                    </div>
                `;
            }
        }

        // NVDI 구글 시트 읽기 함수
        async function readNVDIGoogleSheet() {
            try {
                const url = GOOGLE_SHEETS_URLS.nvdi;
                console.log('Fetching NVDI data from Google Sheets');
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const csvText = await response.text();
                const data = parseCSV(csvText);
                
                // 첫 번째 행은 헤더
                const headers = data[0];
                const yearColumns = {};
                
                // 헤더에서 년도 컬럼 인덱스 찾기
                headers.forEach((header, index) => {
                    if (index > 0) { // 첫 번째 컬럼은 Date
                        const year = parseInt(header.toString().trim());
                        if (!isNaN(year)) {
                            yearColumns[year] = index;
                        }
                    }
                });
                
                console.log('Found year columns:', Object.keys(yearColumns));
                
                // 월별 데이터 집계
                const monthlyData = [];
                
                for (let month = 1; month <= 12; month++) {
                    const monthRows = [];
                    
                    // 해당 월의 모든 행 찾기
                    for (let i = 1; i < data.length; i++) {
                        const row = data[i];
                        if (row && row[0]) {
                            // DD/MM 형식에서 월 추출
                            const dateParts = row[0].toString().split('/');
                            if (dateParts.length === 2) {
                                const rowMonth = parseInt(dateParts[1]);
                                if (rowMonth === month) {
                                    monthRows.push(row);
                                }
                            }
                        }
                    }
                    
                    if (monthRows.length > 0) {
                        // 2010-2023년 데이터에서 min/max 계산
                        const allValues = [];
                        for (const row of monthRows) {
                            for (let year = 2010; year <= 2023; year++) {
                                const colIndex = yearColumns[year];
                                if (colIndex && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== "") {
                                    const value = parseFloat(row[colIndex]);
                                    if (!isNaN(value)) {
                                        allValues.push(value);
                                    }
                                }
                            }
                        }
                        
                        const minValue = allValues.length > 0 ? Math.min(...allValues) : null;
                        const maxValue = allValues.length > 0 ? Math.max(...allValues) : null;
                        
                        // 2024년과 2025년 데이터 (평균값 계산)
                        let year2024Values = [];
                        let year2025Values = [];
                        
                        for (const row of monthRows) {
                            const val2024 = yearColumns[2024] ? parseFloat(row[yearColumns[2024]]) : null;
                            const val2025 = yearColumns[2025] ? parseFloat(row[yearColumns[2025]]) : null;
                            
                            if (!isNaN(val2024) && val2024 !== null) year2024Values.push(val2024);
                            if (!isNaN(val2025) && val2025 !== null) year2025Values.push(val2025);
                        }
                        
                        const avg2024 = year2024Values.length > 0 ? 
                            year2024Values.reduce((sum, val) => sum + val, 0) / year2024Values.length : null;
                        const avg2025 = year2025Values.length > 0 ? 
                            year2025Values.reduce((sum, val) => sum + val, 0) / year2025Values.length : null;
                        
                        monthlyData.push({
                            month: month,
                            minValue: minValue,
                            maxValue: maxValue,
                            year2024: avg2024,
                            year2025: avg2025
                        });
                        
                        console.log(`Month ${month}: ${monthRows.length} rows, min=${minValue?.toFixed(3)}, max=${maxValue?.toFixed(3)}, 2024=${avg2024?.toFixed(3)}, 2025=${avg2025?.toFixed(3)}`);
                    }
                }
                
                console.log('Successfully processed NVDI data:', monthlyData.length, 'months');
                return monthlyData;
                
            } catch (error) {
                console.error('Error reading NVDI Google Sheet:', error);
                return null;
            }
        }

        // 리포트 렌더링 (최근 4개만 표시 + More 버튼)
        function renderReports(filteredReports = allReports) {
            const grid = document.getElementById('reportsGrid');
            const noResults = document.getElementById('noResults');
            const moreContainer = document.getElementById('moreReportsContainer');
            const moreBtn = document.getElementById('moreReportsBtn');
            
            if (filteredReports.length === 0) {
                grid.style.display = 'none';
                noResults.style.display = 'block';
                moreContainer.style.display = 'none';
                return;
            }
            
            grid.style.display = 'grid';
            noResults.style.display = 'none';
            
            // 날짜순으로 정렬하여 가장 최근 보고서 찾기
            const sortedReports = [...filteredReports].sort((a, b) => new Date(b.date) - new Date(a.date));
            const latestDate = sortedReports.length > 0 ? sortedReports[0].date : null;
            
            // 최근 4개와 나머지 분리
            const recentReports = sortedReports.slice(0, 4);
            const olderReports = sortedReports.slice(4);
            
            // More 버튼 표시 여부 결정
            if (olderReports.length > 0) {
                moreContainer.style.display = 'block';
                
                // More 버튼 이벤트 리스너 (중복 방지)
                const newMoreBtn = moreBtn.cloneNode(true);
                moreBtn.parentNode.replaceChild(newMoreBtn, moreBtn);
                
                let isExpanded = false;
                newMoreBtn.addEventListener('click', () => {
                    isExpanded = !isExpanded;
                    
                    if (isExpanded) {
                        // 나머지 보고서들 표시
                        olderReports.forEach((report, index) => {
                            const isLatest = report.date === latestDate;
                            const card = createReportCard(report, isLatest);
                            card.classList.add('show-more');
                            card.style.animationDelay = `${index * 0.1}s`;
                            grid.appendChild(card);
                        });
                        
                        newMoreBtn.classList.add('expanded');
                        newMoreBtn.querySelector('.more-text').textContent = 'Show';
                    } else {
                        // 나머지 보고서들 숨기기
                        const moreCards = grid.querySelectorAll('.show-more');
                        moreCards.forEach(card => card.remove());
                        
                        newMoreBtn.classList.remove('expanded');
                        newMoreBtn.querySelector('.more-text').textContent = 'More Reports';
                    }
                });
            } else {
                moreContainer.style.display = 'none';
            }
            
            // 최근 4개 보고서만 먼저 표시
            grid.innerHTML = '';
            recentReports.forEach(report => {
                const isLatest = report.date === latestDate;
                const card = createReportCard(report, isLatest);
                grid.appendChild(card);
            });
        }
        
        // 보고서 카드 생성 함수
        function createReportCard(report, isLatest) {
            const card = document.createElement('div');
            card.className = 'report-card';
            card.onclick = () => {
                // 트래픽 추적: 보고서 조회
                if (window.trackReportView) {
                    window.trackReportView(report.date, 'weekly');
                }
                window.location.href = report.link;
            };
            
            card.innerHTML = `
                <div class="report-date">${report.displayDate}</div>
                <h3 class="report-title">
                    <span>${report.title}</span>
                    ${isLatest ? '<span class="new-badge">NEW</span>' : ''}
                </h3>
                <p class="report-summary">${report.summary}</p>
                <div class="report-tags">
                    ${report.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                </div>
                <a href="${report.link}" class="read-more" onclick="event.stopPropagation(); if(window.trackReportView) window.trackReportView('${report.date}', 'weekly');">보고서 읽기</a>
            `;
            
            return card;
        }

        // 리포트 필터링
        function filterReports() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const yearFilter = document.getElementById('yearFilter').value;
            const monthFilter = document.getElementById('monthFilter').value;
            
            const filtered = allReports.filter(report => {
                const matchesSearch = report.title.toLowerCase().includes(searchTerm) || 
                                    report.summary.toLowerCase().includes(searchTerm) ||
                                    report.tags.some(tag => tag.toLowerCase().includes(searchTerm));
                const matchesYear = !yearFilter || report.year === yearFilter;
                const matchesMonth = !monthFilter || report.month === monthFilter;
                
                return matchesSearch && matchesYear && matchesMonth;
            });
            
            renderReports(filtered);
        }

        // 필터 옵션 업데이트
        function updateFilters() {
            const years = [...new Set(allReports.map(r => r.year))].sort().reverse();
            const months = [...new Set(allReports.map(r => r.month))].sort();
            
            const yearSelect = document.getElementById('yearFilter');
            const monthSelect = document.getElementById('monthFilter');
            
            if (yearSelect) {
                yearSelect.innerHTML = '<option value="">전체 년도</option>';
                years.forEach(year => {
                    yearSelect.innerHTML += `<option value="${year}">${year}년</option>`;
                });
            }
            
            if (monthSelect) {
                monthSelect.innerHTML = '<option value="">전체 월</option>';
                months.forEach(month => {
                    const monthName = parseInt(month) + '월';
                    monthSelect.innerHTML += `<option value="${month}">${monthName}</option>`;
                });
            }
        }

        // 통계 업데이트
        function updateStats() {
            const totalElement = document.getElementById('totalReports');
            const latestElement = document.getElementById('latestDate');
            
            if (totalElement) {
                totalElement.textContent = allReports.length;
            }
            
            if (latestElement && allReports.length > 0) {
                latestElement.textContent = allReports[0].displayDate.substring(0, 7);
            }
            
            // Latest Report 링크 업데이트
            updateLatestReportLink();
        }

        // Latest Report 링크 업데이트 함수
        function updateLatestReportLink() {
            const latestReportLink = document.getElementById('latestReportLink');
            if (latestReportLink && allReports.length > 0) {
                // 날짜순으로 정렬하여 가장 최신 보고서 찾기
                const sortedReports = [...allReports].sort((a, b) => new Date(b.date) - new Date(a.date));
                const latestReport = sortedReports[0];
                
                if (latestReport) {
                    latestReportLink.href = latestReport.link;
                    console.log('Latest Report Link updated to:', latestReport.link);
                }
            }
        }

        // 현재 날짜 업데이트
        function updateCurrentDate() {
            const dateElement = document.getElementById('currentDate');
            if (dateElement) {
                const now = new Date();
                const options = { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    weekday: 'short'
                };
                const formattedDate = now.toLocaleDateString('ko-KR', options);
                dateElement.textContent = formattedDate;
            }
        }

        // 메인 초기화 함수
        async function init() {
            try {
                console.log('초기화 시작...');
                
                // 현재 날짜 업데이트
                updateCurrentDate();
                
                // 차트들 병렬로 로드
                Promise.all([
                    createCoffeeChart(),
                    createUSDChart(),
                    createCFTCChart(),
                    createNVDIChart()
                ]);

                // 개선된 리포트 데이터 로드
                allReports = await initializeReports();
                updateFilters();
                updateStats();
                renderReports();
                
                // 이벤트 리스너 설정
                document.getElementById('searchInput').addEventListener('input', filterReports);
                document.getElementById('yearFilter').addEventListener('change', filterReports);
                document.getElementById('monthFilter').addEventListener('change', filterReports);
                
                console.log('초기화 완료');
                
            } catch (error) {
                console.error('초기화 중 오류:', error);
            }
        }

        // 페이지 로드시 초기화 실행
        document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
