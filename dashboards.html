<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboards - Coffee Market Updates</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Arial', 'Helvetica', sans-serif;
            line-height: 1.7;
            color: #2c3e50;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 50px;
            padding: 40px 20px;
        }
        
        h1 {
            font-size: 3em;
            color: #8B4513;
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        .subtitle {
            font-size: 1.3em;
            color: #666;
            margin-bottom: 30px;
        }
        
        .back-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-button:hover {
            transform: translateX(-5px);
            box-shadow: 0 5px 15px rgba(139, 69, 19, 0.3);
        }
        
        /* 차트 대시보드 스타일 (index.html과 동일) */
        .dashboard-section {
            margin-bottom: 50px;
            position: relative;
        }
        
        .dashboard-section::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 600px;
            height: 600px;
            background-image: url('coffee-beans-pattern.jpg');
            background-size: contain;
            background-repeat: no-repeat;
            opacity: 0.06;
            transform: translate(-50%, -50%) rotate(15deg);
            z-index: -1;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
        }
        
        .chart-header {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .chart-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .chart-source {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }
        
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .chart-analysis {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid #8B4513;
            font-size: 0.9em;
            line-height: 1.5;
            color: #495057;
        }
        
        .chart-analysis .analysis-title {
            font-weight: 600;
            color: #8B4513;
            margin-bottom: 6px;
            font-size: 0.95em;
        }
        
        .chart-analysis .analysis-text {
            font-size: 0.85em;
            color: #6c757d;
        }
        
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 400px;
            font-size: 1.1em;
            color: #666;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #8B4513;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2em;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-button">
            ← 메인 페이지로 돌아가기
        </a>
        
        <div class="header">
            <h1>Market Dashboards</h1>
            <p class="subtitle">커피 시장 핵심 지표 대시보드</p>
        </div>
        
        <!-- 차트 대시보드 섹션 -->
        <div class="dashboard-section">
            <div class="charts-grid">
                <!-- Coffee Futures Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">Coffee Futures</div>
                        <div class="chart-source">출처: ICE</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-coffee">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="coffeeChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">📊 차트 분석</div>
                        <div class="analysis-text">
                            <strong>커피 선물 가격</strong>은 글로벌 커피 시장의 미래 가격 기대치를 반영합니다. 
                            브라질/베트남 등 주요 생산국의 작황, 기후 변화, 글로벌 수요 변화가 주요 변동 요인입니다. 
                            현재 추세는 시장의 공급/수요 균형과 투기적 포지션 변화를 나타냅니다.
                        </div>
                    </div>
                </div>

                <!-- USD/BRL Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">미국달러-브라질헤알 환율</div>
                        <div class="chart-source">출처: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-usd">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="usdChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">💱 차트 분석</div>
                        <div class="analysis-text">
                            <strong>USD/BRL 환율</strong>은 커피 시장에 중요한 영향을 미칩니다. 
                            헤알화 약세(USD/BRL 상승) 시 브라질 농민들의 달러 수취액이 증가해 수출 경쟁력이 강화되고, 
                            반대로 헤알화 강세 시에는 브라질 커피의 국제 경쟁력이 약화됩니다. 
                            브라질이 세계 최대 커피 생산국이므로 환율 변동은 글로벌 커피 가격에 직접적 영향을 줍니다.
                        </div>
                    </div>
                </div>

                <!-- CFTC Positions Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">CFTC 투기 포지션 (순매수)</div>
                        <div class="chart-source">출처: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-cftc">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="cftcChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">📈 차트 분석</div>
                        <div class="analysis-text">
                            <strong>CFTC 머니매니저 순매수 포지션</strong>은 대형 펀드들의 커피 시장 심리를 보여줍니다. 
                            양수는 강세 베팅(매수 우세), 음수는 약세 베팅(매도 우세)을 의미합니다. 
                            극단적 포지션은 종종 시장 전환점의 신호가 되며, 
                            현재 포지션 수준은 투기 자금의 방향성과 시장 과열/과매도 상태를 판단하는 중요한 지표입니다.
                        </div>
                    </div>
                </div>

                <!-- NVDI Chart -->
                <div class="chart-container">
                    <div class="chart-header">
                        <div class="chart-title">브라질 남동부 NVDI (식물활력도)</div>
                        <div class="chart-source">출처: LSEG</div>
                    </div>
                    <div class="chart-wrapper">
                        <div class="loading-spinner" id="loading-nvdi">
                            <div class="spinner"></div>
                            데이터 로딩 중...
                        </div>
                        <canvas id="nvdiChart" style="display: none;"></canvas>
                    </div>
                    <div class="chart-analysis">
                        <div class="analysis-title">🌱 차트 분석</div>
                        <div class="analysis-text">
                            <strong>NVDI (정규식생지수)</strong>는 위성 데이터로 측정한 식물의 건강도와 활력도를 나타냅니다. 
                            브라질 남동부는 세계 최대 아라비카 커피 생산지역으로, NVDI 수치가 높을수록 커피나무가 건강하고 
                            수확량 증가가 예상됩니다. 역사적 범위 대비 현재 수치를 통해 
                            올해 작황 상태와 향후 공급량 전망을 예측할 수 있는 핵심 지표입니다.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let charts = {};

        // 구글 시트 URL 설정 (index.html과 동일)
        const GOOGLE_SHEETS_URLS = {
            coffeefutures: 'https://docs.google.com/spreadsheets/d/1lnRrdQynfk-XrgYsKmf1_XFCBDa9jLr2XVRib-2lpTk/export?format=csv&gid=442491515',
            usdbrl: 'https://docs.google.com/spreadsheets/d/1FvqTjVTw_iCtZ9pQOHc1UBN7ghYvrdp_MOLTxsSLTyM/export?format=csv&gid=88171284',
            cftcpositions: 'https://docs.google.com/spreadsheets/d/1IgfIFB60VC2f3IGnU5m9xmqkmfOCnnAOYItj9SWKMxc/export?format=csv&gid=0',
            nvdi: 'https://docs.google.com/spreadsheets/d/1oxXXeBQDZmiq9te6fNkKTs9D1X8ruwUI0_yy8UOj7gI/export?format=csv&gid=0'
        };

        // CSV 파싱 함수
        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line) {
                    const cells = line.split(',');
                    result.push(cells);
                }
            }
            
            return result;
        }

        // 날짜 변환 함수
        function parseDate(dateValue) {
            if (typeof dateValue === 'number') {
                // Excel 날짜 시리얼 번호인 경우
                const date = new Date((dateValue - 25569) * 86400 * 1000);
                return date;
            } else if (typeof dateValue === 'string') {
                return new Date(dateValue);
            }
            return new Date(dateValue);
        }

        // 구글 시트에서 데이터 읽기 함수 (2컬럼: Date, Value)
        async function readGoogleSheetData(sheetKey) {
            try {
                const url = GOOGLE_SHEETS_URLS[sheetKey];
                if (!url) {
                    throw new Error(`Unknown sheet key: ${sheetKey}`);
                }

                console.log(`Fetching data from Google Sheets: ${sheetKey}`);
                
                let csvText;
                
                // 먼저 직접 접근 시도
                try {
                    const directResponse = await fetch(url);
                    if (directResponse.ok) {
                        csvText = await directResponse.text();
                        console.log(`Direct access successful for ${sheetKey}`);
                    } else {
                        throw new Error('Direct access failed');
                    }
                } catch (directError) {
                    // 직접 접근 실패시 AllOrigins 프록시 사용
                    console.log(`Direct access failed for ${sheetKey}, trying proxy...`);
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    
                    const proxyResponse = await fetch(proxyUrl);
                    if (!proxyResponse.ok) {
                        throw new Error(`Proxy also failed: ${proxyResponse.status}`);
                    }
                    
                    const proxyData = await proxyResponse.json();
                    csvText = proxyData.contents;
                    console.log(`Proxy access successful for ${sheetKey}`);
                }
                const data = parseCSV(csvText);
                
                // 첫 번째 행은 헤더이므로 제외하고 데이터 처리
                const dataRows = data.slice(1);
                
                const processedData = dataRows.map(row => ({
                    date: row[0], // 첫 번째 컬럼은 항상 Date
                    value: row[1] // 두 번째 컬럼은 해당 값
                })).filter(row => row.date && row.value !== undefined && row.value !== null && row.value !== '');
                
                // 날짜순으로 정렬 (오래된 것 → 최신 순서로)
                processedData.sort((a, b) => parseDate(a.date) - parseDate(b.date));
                
                console.log(`Successfully loaded ${processedData.length} data points from ${sheetKey}`);
                return processedData;
                
            } catch (error) {
                console.error(`Error reading Google Sheet ${sheetKey}:`, error);
                return null;
            }
        }

        // Coffee Futures 차트
        async function createCoffeeChart() {
            const loadingElement = document.getElementById('loading-coffee');
            const chartElement = document.getElementById('coffeeChart');
            
            try {
                const data = await Promise.race([
                    readGoogleSheetData('coffeefutures'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseFloat(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.coffee = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'Coffee Futures Price',
                            data: chartData,
                            borderColor: '#8B4513',
                            backgroundColor: 'rgba(139, 69, 19, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#8B4513' : 'transparent'
                            ),
                            pointBorderColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#FFFFFF' : 'transparent'
                            ),
                            pointBorderWidth: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 2 : 0
                            ),
                            pointRadius: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 4 : 0
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index] && index >= 0 && index < chartData.length) {
                                            const totalPoints = chartData.length;
                                            const step = Math.max(1, Math.floor(totalPoints / 8));
                                            
                                            if (index === 0 || index === totalPoints - 1 || index % step === 0) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    stepSize: Math.max(1, Math.floor(chartData.length / 8)),
                                    maxTicksLimit: 10,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Price (cents/lb)'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Coffee chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">데이터 로딩 실패: ' + error.message + '</div>';
            }
        }

        // USD/BRL 환율 차트
        async function createUSDChart() {
            const loadingElement = document.getElementById('loading-usd');
            const chartElement = document.getElementById('usdChart');
            
            try {
                const data = await Promise.race([
                    readGoogleSheetData('usdbrl'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row, index) => ({
                    x: index,
                    y: parseFloat(row.value),
                    date: parseDate(row.date)
                })).filter(point => !isNaN(point.y));

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.usd = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [{
                            label: 'USD/BRL Rate',
                            data: chartData,
                            borderColor: '#2E8B57',
                            backgroundColor: 'rgba(46, 139, 87, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 6,
                            pointBackgroundColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#2E8B57' : 'transparent'
                            ),
                            pointBorderColor: chartData.map((_, index) => 
                                index === chartData.length - 1 ? '#FFFFFF' : 'transparent'
                            ),
                            pointBorderWidth: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 2 : 0
                            ),
                            pointRadius: chartData.map((_, index) => 
                                index === chartData.length - 1 ? 4 : 0
                            )
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: 'Date'
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        if (chartData[index] && index >= 0 && index < chartData.length) {
                                            const totalPoints = chartData.length;
                                            const step = Math.max(1, Math.floor(totalPoints / 8));
                                            
                                            if (index === 0 || index === totalPoints - 1 || index % step === 0) {
                                                return chartData[index].date.toLocaleDateString('ko-KR', { 
                                                    year: '2-digit', 
                                                    month: 'short' 
                                                });
                                            }
                                        }
                                        return '';
                                    },
                                    stepSize: Math.max(1, Math.floor(chartData.length / 8)),
                                    maxTicksLimit: 10,
                                    maxRotation: 45,
                                    minRotation: 0
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'BRL per USD'
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('USD chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">데이터 로딩 실패: ' + error.message + '</div>';
            }
        }

        // CFTC 포지션 차트 (바 차트)
        async function createCFTCChart() {
            const loadingElement = document.getElementById('loading-cftc');
            const chartElement = document.getElementById('cftcChart');
            
            try {
                const data = await Promise.race([
                    readGoogleSheetData('cftcpositions'),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!data) {
                    throw new Error('No data received');
                }

                const chartData = data.map((row) => ({
                    y: parseInt(row.value),
                    date: parseDate(row.date),
                    dateString: row.date
                })).filter(point => !isNaN(point.y) && point.date);

                // 날짜 기준으로 정렬
                chartData.sort((a, b) => a.date.getTime() - b.date.getTime());

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                
                // 모바일 여부 확인
                const isMobile = window.innerWidth <= 768;
                
                // 3개월 간격으로 레이블 인덱스 선택
                const totalData = chartData.length;
                const step = Math.max(Math.floor(totalData / 6), 1);
                
                // 바 차트용 레이블을 모든 데이터 포인트에 대해 생성
                const labels = chartData.map((item, index) => {
                    if (index === 0 || index === totalData - 1 || index % step === 0) {
                        if (isMobile) {
                            return item.date.toLocaleDateString('ko-KR', { 
                                year: '2-digit',
                                month: 'short'
                            });
                        } else {
                            return item.date.toLocaleDateString('ko-KR', { 
                                year: 'numeric', 
                                month: 'long'
                            });
                        }
                    }
                    return ' ';
                });
                
                charts.cftc = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Net Long Positions',
                            data: chartData.map(d => d.y),
                            backgroundColor: chartData.map(point => point.y >= 0 ? '#27AE60' : '#E74C3C'),
                            borderColor: chartData.map(point => point.y >= 0 ? '#229954' : '#C0392B'),
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return chartData[index].date.toLocaleDateString('ko-KR', {
                                            year: 'numeric',
                                            month: 'long',
                                            day: 'numeric'
                                        });
                                    },
                                    label: function(context) {
                                        return 'Net Long: ' + context.parsed.y.toLocaleString();
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date (3개월 단위)'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 0,
                                    font: {
                                        size: isMobile ? 11 : 13,
                                        weight: 'bold'
                                    },
                                    color: '#333',
                                    autoSkip: false
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Net Long Positions'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toLocaleString();
                                    }
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('CFTC chart error:', error);
                loadingElement.innerHTML = '<div style="color: #e74c3c;">데이터 로딩 실패: ' + error.message + '</div>';
            }
        }

        // NVDI 구글 시트 읽기 함수
        async function readNVDIGoogleSheet() {
            try {
                const url = GOOGLE_SHEETS_URLS.nvdi;
                console.log('Fetching NVDI data from Google Sheets');
                
                let csvText;
                
                // 먼저 직접 접근 시도
                try {
                    const directResponse = await fetch(url);
                    if (directResponse.ok) {
                        csvText = await directResponse.text();
                        console.log('Direct access successful for NVDI');
                    } else {
                        throw new Error('Direct access failed');
                    }
                } catch (directError) {
                    // 직접 접근 실패시 AllOrigins 프록시 사용
                    console.log('Direct access failed for NVDI, trying proxy...');
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    
                    const proxyResponse = await fetch(proxyUrl);
                    if (!proxyResponse.ok) {
                        throw new Error(`Proxy also failed: ${proxyResponse.status}`);
                    }
                    
                    const proxyData = await proxyResponse.json();
                    csvText = proxyData.contents;
                    console.log('Proxy access successful for NVDI');
                }
                const data = parseCSV(csvText);
                
                // 첫 번째 행은 헤더
                const headers = data[0];
                const yearColumns = {};
                
                // 헤더에서 년도 컬럼 인덱스 찾기
                headers.forEach((header, index) => {
                    if (index > 0) { // 첫 번째 컬럼은 Date
                        const year = parseInt(header.toString().trim());
                        if (!isNaN(year)) {
                            yearColumns[year] = index;
                        }
                    }
                });
                
                console.log('Found year columns:', Object.keys(yearColumns));
                
                // 월별 데이터 집계
                const monthlyData = [];
                
                for (let month = 1; month <= 12; month++) {
                    const monthRows = [];
                    
                    // 해당 월의 모든 행 찾기
                    for (let i = 1; i < data.length; i++) {
                        const row = data[i];
                        if (row && row[0]) {
                            // DD/MM 형식에서 월 추출
                            const dateParts = row[0].toString().split('/');
                            if (dateParts.length === 2) {
                                const rowMonth = parseInt(dateParts[1]);
                                if (rowMonth === month) {
                                    monthRows.push(row);
                                }
                            }
                        }
                    }
                    
                    if (monthRows.length > 0) {
                        // 2010-2023년 데이터에서 min/max 계산
                        const allValues = [];
                        for (const row of monthRows) {
                            for (let year = 2010; year <= 2023; year++) {
                                const colIndex = yearColumns[year];
                                if (colIndex && row[colIndex] !== undefined && row[colIndex] !== null && row[colIndex] !== "") {
                                    const value = parseFloat(row[colIndex]);
                                    if (!isNaN(value)) {
                                        allValues.push(value);
                                    }
                                }
                            }
                        }
                        
                        const minValue = allValues.length > 0 ? Math.min(...allValues) : null;
                        const maxValue = allValues.length > 0 ? Math.max(...allValues) : null;
                        
                        // 2024년과 2025년 데이터 (평균값 계산)
                        let year2024Values = [];
                        let year2025Values = [];
                        
                        for (const row of monthRows) {
                            const val2024 = yearColumns[2024] ? parseFloat(row[yearColumns[2024]]) : null;
                            const val2025 = yearColumns[2025] ? parseFloat(row[yearColumns[2025]]) : null;
                            
                            if (!isNaN(val2024) && val2024 !== null) year2024Values.push(val2024);
                            if (!isNaN(val2025) && val2025 !== null) year2025Values.push(val2025);
                        }
                        
                        const avg2024 = year2024Values.length > 0 ? 
                            year2024Values.reduce((sum, val) => sum + val, 0) / year2024Values.length : null;
                        const avg2025 = year2025Values.length > 0 ? 
                            year2025Values.reduce((sum, val) => sum + val, 0) / year2025Values.length : null;
                        
                        monthlyData.push({
                            month: month,
                            minValue: minValue,
                            maxValue: maxValue,
                            year2024: avg2024,
                            year2025: avg2025
                        });
                    }
                }
                
                console.log('Successfully processed NVDI data:', monthlyData.length, 'months');
                return monthlyData;
                
            } catch (error) {
                console.error('Error reading NVDI Google Sheet:', error);
                return null;
            }
        }

        // NVDI 차트
        async function createNVDIChart() {
            const loadingElement = document.getElementById('loading-nvdi');
            const chartElement = document.getElementById('nvdiChart');
            
            try {
                const nvdiData = await Promise.race([
                    readNVDIGoogleSheet(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]);
                
                if (!nvdiData || nvdiData.length === 0) {
                    throw new Error('NVDI 데이터를 읽을 수 없습니다');
                }

                const monthKR = ['1월', '2월', '3월', '4월', '5월', '6월', 
                               '7월', '8월', '9월', '10월', '11월', '12월'];

                const datasets = [];

                // Min-Max 범위 상한선
                const maxData = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.maxValue
                })).filter(point => point.y !== null);

                datasets.push({
                    label: 'Historical Range (2010-2023)',
                    data: maxData,
                    borderColor: 'rgba(149, 165, 166, 0.8)',
                    backgroundColor: 'rgba(149, 165, 166, 0.3)',
                    borderWidth: 1,
                    fill: '+1',
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 0
                });

                // Min-Max 범위 하한선
                const minData = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.minValue
                })).filter(point => point.y !== null);

                datasets.push({
                    label: '',
                    data: minData,
                    borderColor: 'rgba(149, 165, 166, 0.8)',
                    backgroundColor: 'rgba(149, 165, 166, 0.3)',
                    borderWidth: 1,
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 0
                });

                // 2024년 라인
                const data2024 = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.year2024
                })).filter(point => point.y !== null && !isNaN(point.y));

                if (data2024.length > 0) {
                    datasets.push({
                        label: '2024',
                        data: data2024,
                        borderColor: '#E74C3C',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#E74C3C',
                        pointBorderColor: '#FFFFFF',
                        pointBorderWidth: 2
                    });
                }

                // 2025년 라인
                const data2025 = nvdiData.map((item, index) => ({
                    x: index,
                    y: item.year2025
                })).filter(point => point.y !== null && !isNaN(point.y));

                if (data2025.length > 0) {
                    datasets.push({
                        label: '2025',
                        data: data2025,
                        borderColor: '#3498DB',
                        backgroundColor: 'transparent',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#3498DB',
                        pointBorderColor: '#FFFFFF',
                        pointBorderWidth: 2
                    });
                }

                loadingElement.style.display = 'none';
                chartElement.style.display = 'block';

                const ctx = chartElement.getContext('2d');
                charts.nvdi = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    filter: function(item) {
                                        return item.text !== '';
                                    },
                                    usePointStyle: false,
                                    padding: 20,
                                    font: {
                                        size: 12
                                    },
                                    generateLabels: function(chart) {
                                        const datasets = chart.data.datasets;
                                        return datasets.map((dataset, i) => {
                                            if (dataset.label && dataset.label !== '') {
                                                return {
                                                    text: dataset.label,
                                                    fillStyle: dataset.borderColor,
                                                    strokeStyle: dataset.borderColor,
                                                    lineWidth: 3,
                                                    hidden: !chart.isDatasetVisible(i),
                                                    datasetIndex: i
                                                };
                                            }
                                        }).filter(item => item);
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(tooltipItems) {
                                        const index = tooltipItems[0].dataIndex;
                                        return monthKR[index] || `월 ${index + 1}`;
                                    },
                                    label: function(context) {
                                        if (context.datasetIndex === 0) {
                                            const index = context.dataIndex;
                                            const dataPoint = nvdiData[index];
                                            if (dataPoint) {
                                                return `Range: ${dataPoint.minValue?.toFixed(3)} - ${dataPoint.maxValue?.toFixed(3)}`;
                                            }
                                            return 'Range data';
                                        } else if (context.datasetIndex === 1) {
                                            return '';
                                        }
                                        return context.dataset.label + ': ' + (context.parsed.y ? context.parsed.y.toFixed(3) : 'N/A');
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: '월',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    callback: function(value) {
                                        const index = Math.round(value);
                                        return monthKR[index] || '';
                                    },
                                    maxTicksLimit: 12,
                                    stepSize: 1
                                },
                                min: 0,
                                max: 11,
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'NVDI Index',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
                
                console.log('NVDI 차트 생성 완료');
                
            } catch (error) {
                console.error('NVDI chart error:', error);
                loadingElement.innerHTML = `
                    <div style="color: #e74c3c; text-align: center;">
                        <strong>NVDI 데이터 로딩 실패</strong><br>
                        <small>${error.message}</small><br>
                        <small style="margin-top: 10px; display: block;">
                            구글 시트에서 데이터를 읽을 수 없습니다.
                        </small>
                    </div>
                `;
            }
        }

        // 메인 초기화 함수
        async function init() {
            try {
                console.log('대시보드 초기화 시작...');
                
                // 차트들 병렬로 로드
                await Promise.all([
                    createCoffeeChart(),
                    createUSDChart(),
                    createCFTCChart(),
                    createNVDIChart()
                ]);
                
                console.log('대시보드 초기화 완료');
                
            } catch (error) {
                console.error('대시보드 초기화 중 오류:', error);
            }
        }

        // 페이지 로드시 초기화 실행
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
